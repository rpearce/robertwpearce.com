<!DOCTYPE html><html lang="en"><head><title>JavaScript: Writing a Functional Programming-Style map Function</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors."><meta name="author" content="Robert Pearce"><meta name="keywords" content="javascript, map, map function, functional programming, js, programming"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="JavaScript: Writing a Functional Programming-Style map Function"><meta property="og:url" content="https://robertwpearce.com/javascript-writing-a-functional-programming-style-map-function.html"><meta property="og:description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="JavaScript: Writing a Functional Programming-Style map Function"><meta property="twitter:description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>💾</text></svg>"><link rel="canonical" href="https://robertwpearce.com/javascript-writing-a-functional-programming-style-map-function.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>JavaScript: Writing a Functional Programming-Style map Function</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>Learn how to write a generic map function to map Arrays, Objects, and Functors.</td></tr><tr><th>Shared</th><td>2020-02-20</td></tr></tbody></table></section><section data-area="note"><p><em>Many thanks to <a href="https://twitter.com/goodforenergy">Helen Durrant</a> for reviewing this post and offering stellar suggestions.</em></p><p>In this post, we will write a functional programming-style implementation of JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map</code></a> function that not only works with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a> but any data structure that implements a <code>map</code> method. Such data structures are known as <a href="https://github.com/hemanth/functional-programming-jargon#functor"><code>Functors</code></a>. Some examples of <code>Functors</code> are the algebraic data types<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a> and <a href="https://crocks.dev/docs/crocks/Async.html"><code>Async</code></a> (prior knowledge of them is not required, and out of the two, we’ll only use <code>Maybe</code>).</p><p>By the end of this post, you will:</p><ul><li>know how to implement a generic <code>map</code> function that includes functions for <code>map</code>ping <code>Array</code>s, <code>Object</code>s, and <code>Functor</code>s</li><li>understand how to use <code>map</code> in a variety of scenarios</li><li>know how to write a simple <code>compose</code> function and use composition</li><li>know how to reliably test values for their types</li><li>have received a small introduction to algebraic data types via the <a href="https://crocks.dev"><code>crocks</code></a> library</li></ul><p>This is a big post, so buckle up! If you want to see the final product, check out this CodeSandbox: <a href="https://codesandbox.io/s/bitter-grass-tknwb" class="uri">https://codesandbox.io/s/bitter-grass-tknwb</a>.</p><hr /><p><em>Note: if you’re not familiar with <code>Array.prototype.map</code> already, check out my video on <a href="https://www.youtube.com/watch?v=tjjg3_jyD7M">Using JavaScript’s Array.prototype.map Method</a> or my post on <a href="https://robertwpearce.com/javascript-understand-array-prototype-map-by-reimplementing-it.html">JavaScript: Understand Array.prototype.map by Reimplementing It</a>.</em></p><p><em>We will use the implementation of the <code>map</code> function in <a href="https://crocks.dev">crocks</a> as our template, so if you want to skip this article entirely, you can go and view <a href="https://github.com/evilsoft/crocks/blob/e4517493079538960d53715ef25d72c264cfecf0/src/pointfree/map.js#L15-L38">its source</a>.</em></p><h2 id="overview">Overview</h2><ol><li><a href="#the-goal-map-all-the-things">The Goal: <code>map</code> All the Things</a></li><li><a href="#defining-our-map-function">Defining Our <code>map</code> Function</a></li><li><a href="#map-an-array"><code>map</code> an <code>Array</code></a></li><li><a href="#map-an-object"><code>map</code> an <code>Object</code></a></li><li><a href="#map-a-function"><code>map</code> a <code>Function</code></a></li><li><a href="#map-a-functor"><code>map</code> a <code>Functor</code></a></li><li><a href="#throwing-out-bad-data"><code>throw</code>ing Out Bad Data</a></li></ol><h2 id="the-goal-map-all-the-things">The Goal: <code>map</code> All the Things</h2><p>Today we are going to write a <code>map</code> function that does the following:</p><ul><li>accepts a transformation function that takes in some argument of type <code>a</code> and transforms it into a value of type <code>b</code>; i.e., <code>(a -&gt; b)</code></li><li>accepts and handles any of the following data types: <ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></li><li><a href="https://github.com/hemanth/functional-programming-jargon#functor"><code>Functors</code></a> (e.g., <a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a>)</li></ul></li></ul><p>Sounds easy, right? We’ll see!</p><h2 id="defining-our-map-function">Defining Our <code>map</code> Function</h2><p>There are some things we already know about our <code>map</code> function:</p><ul><li>it’s called <code>map</code> (yay! nailed it!)</li><li>it takes a function (<code>fn</code>) and then some datum (<code>m</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li><li>it returns the datum as transformed by said function</li></ul><p>Let’s sketch it out:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// ???
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">}</span></span></span></code></pre><p>Okay, it’s a start. This could conceivably be used like this:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">id</span><span class="pl-p">,</span> <span class="pl-p">[{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">1</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">2</span> <span class="pl-p">}])</span>     <span class="pl-c1">// [1, 2]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">id</span><span class="pl-p">,</span> <span class="pl-p">[{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'a'</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'b'</span> <span class="pl-p">}])</span> <span class="pl-c1">// ['a', 'b']
</span></span></span></code></pre><p>Note the repetition of the <code>x =&gt; x.id</code>. Let’s try pulling it out into a variable:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">propId</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">id</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">propId</span><span class="pl-p">,</span> <span class="pl-p">[{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">1</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">2</span> <span class="pl-p">}])</span>     <span class="pl-c1">// [1, 2]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">propId</span><span class="pl-p">,</span> <span class="pl-p">[{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'a'</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'b'</span> <span class="pl-p">}])</span> <span class="pl-c1">// ['a', 'b']
</span></span></span></code></pre><p>Alas, that’s not much better – now we’re just repeating the variable!</p><p>Instead, what if we could store our combination of function and <code>map</code> in a variable and then use that to call with our different data? By <a href="https://github.com/hemanth/functional-programming-jargon#partial-application"><em>partially applying</em></a> the function to <code>map</code>, we can!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">mapId</span> <span class="pl-o">=</span> <span class="pl-nx">map</span><span class="pl-p">.</span><span class="pl-nx">bind</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">,</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">id</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">mapId</span><span class="pl-p">([{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">1</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-mi">2</span> <span class="pl-p">}])</span>     <span class="pl-c1">// [1, 2]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">mapId</span><span class="pl-p">([{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'a'</span> <span class="pl-p">},</span> <span class="pl-p">{</span> <span class="pl-nx">id</span><span class="pl-o">:</span> <span class="pl-s1">'b'</span> <span class="pl-p">}])</span> <span class="pl-c1">// ['a', 'b']
</span></span></span></code></pre><p>Nice! Now, let’s go back to our sketch. Let’s turn our <em>binary</em> function (which takes <em>two</em> parameters) to instead be a series of <em>unary</em> functions (which take <em>one</em> parameter<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>).</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// ???
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">}</span></span></span></code></pre><p>Wow, that was easy. By default, languages like <a href="http://learnyouahaskell.com/higher-order-functions">Haskell</a> and <a href="https://guide.elm-lang.org">Elm</a> automatically <a href="https://robertwpearce.com/ramda-chops-function-currying.html">curry</a> all of their function parameters. There are <a href="https://robertwpearce.com/ramda-chops-function-currying.html">ways to automate that in JavaScript</a>, but for today, we will <em>manually</em> curry functions by using arrow functions to simulate it: <code>const sum = a =&gt; b =&gt; a + b</code>, for example.</p><p>Lastly, on the function definition side, it would be helpful for readers of our code to understand more about the intended types. In lieu of JavaScript not having a static type checker and me not knowing <a href="https://www.typescriptlang.org/">TypeScript</a> yet, we’ll do this using a Haskell-style pseudo-type signature:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">map</span> <span class="pl-ow">::</span> <span class="pl-kt">Functor</span> <span class="pl-n">f</span> <span class="pl-ow">=&gt;</span> <span class="pl-p">(</span><span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">b</span><span class="pl-p">)</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">b</span></span></span></code></pre><p>And we can place that as a comment above our function:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// ???
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">}</span></span></span></code></pre><p>Woah, woah, woah! What’s all this? Let’s break it down.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">map</span> <span class="pl-ow">::</span> <span class="pl-kt">Functor</span> <span class="pl-n">f</span> <span class="pl-ow">=&gt;</span> <span class="pl-p">(</span><span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">b</span><span class="pl-p">)</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">b</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">--  |     |            |     |   |      |</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">--  1     2            3     4   5      6</span></span></span></code></pre><ol><li>Can be read, “has the type of”</li><li>Anything after <code>::</code> and before <code>=&gt;</code> in a signature is a <a href="http://www.learnyouahaskell.com/types-and-typeclasses">class constraint</a>. This says we’re going to use something in the type signature that obeys the Functor Laws<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, <em>identity</em> and <a href="https://robertwpearce.com/ramda-chops-function-composition.html"><em>composition</em></a>. The lowercase <code>f</code> represents what the <code>Functor</code> will be in the signature.</li><li>Our <code>map</code>ping function; e.g., <code>x =&gt; x.id</code>, like we did above.</li><li><code>-&gt;</code> Arrows are used in type signatures to say “then return…”. In our <code>map</code> signature, we say, “We accept a function from <code>a</code> to <code>b</code> then return a function that accepts <code>f</code> of <code>a</code> and then return <code>f</code> of <code>b</code>”. If we were summing three numbers, <code>sum3 :: Number -&gt; Number -&gt; Number -&gt; Number</code>, this would read, “<code>sum3</code> has the type of an expression that accepts a <code>Number</code> that returns a function that accepts a <code>Number</code> then returns a function that accepts a <code>Number</code> and then returns a <code>Number</code>.”</li><li><code>f a</code> says that a <code>Functor</code>, <code>f</code>, wraps some other type, <code>a</code>. A concrete example of this is <code>[Number]</code>, which is a list (or <code>Array</code>) of <code>Number</code>s.</li><li><code>f b</code> says that a <code>Functor</code>, <code>f</code>, wraps some other type, <code>b</code>. Why isn’t it <code>a</code>? This signifies that when we take in the <code>Functor</code> of any type <code>a</code>, it’s totally cool if you want to change the return type inside the <code>Functor</code>. For example, when we take <code>[{ id: 'a' }, { id: 'b' }]</code> and use <code>map</code> to turn that into <code>['a', 'b']</code>, we’re taking <code>[Object]</code> (a list of <code>Object</code>s) and turning that into <code>[String]</code> (a list of <code>String</code>s).</li></ol><p>All together now! “<code>map</code> has the type of an expression where <code>f</code> is a <code>Functor</code>, and it accepts a function from <code>a</code> to <code>b</code>, then returns a function that accepts <code>f</code> of <code>a</code>, and then returns <code>f</code> of <code>b</code>.”</p><h2 id="map-an-array"><code>map</code> an <code>Array</code></h2><p>Let’s <code>map</code> an <code>Array</code>!</p><p>Remember our <code>Functor</code> class constraint?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">map</span> <span class="pl-ow">::</span> <span class="pl-kt">Functor</span> <span class="pl-n">f</span> <span class="pl-ow">=&gt;</span> <span class="pl-p">(</span><span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">b</span><span class="pl-p">)</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">f</span> <span class="pl-n">b</span></span></span></code></pre><p>Guess what? <code>Array</code> is a <code>Functor</code>s! How? It adheres to the laws of <em>identity</em> and <em>composition</em>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// identity
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">)</span> <span class="pl-c1">// [1,2,3]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// composition
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">add10</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">+</span> <span class="pl-mi">10</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">mult2</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">).</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">mult2</span><span class="pl-p">)</span>     <span class="pl-c1">// [ 22, 24, 26 ]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// is equivalent to...
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">mult2</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)))</span> <span class="pl-c1">// [ 22, 24, 26 ]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// another example of the composition law
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">compose</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">f</span><span class="pl-p">,</span> <span class="pl-nx">g</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">f</span><span class="pl-p">(</span><span class="pl-nx">g</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">mult2</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">(</span><span class="pl-mi">2</span><span class="pl-p">))</span> <span class="pl-o">===</span> <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mult2</span><span class="pl-p">,</span> <span class="pl-nx">add10</span><span class="pl-p">)(</span><span class="pl-mi">2</span><span class="pl-p">)</span> <span class="pl-c1">// true
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// and applied back to our prior example
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">).</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">mult2</span><span class="pl-p">)</span>      <span class="pl-c1">// [ 22, 24, 26 ]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">mult2</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)))</span>  <span class="pl-c1">// [ 22, 24, 26 ]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mult2</span><span class="pl-p">,</span> <span class="pl-nx">add10</span><span class="pl-p">))</span> <span class="pl-c1">// [ 22, 24, 26 ]
</span></span></span></code></pre><p>Through <code>map</code>, <code>Array</code> is a <code>Functor</code>. A way to quickly determine if something is a <code>Functor</code> is to ask, “Does it implement <code>map</code> / is it <code>map</code>pable?”</p><p>Since we know that <code>Array</code> is <code>map</code>pable, we can use our <code>map</code> function to check if the <code>f a</code> parameter is an <code>Array</code> and then use the build in <code>Array.prototype.map</code> function to get from <code>a</code> to <code>b</code>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapArray</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isArray :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isArray</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapArray</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">))</span></span></span></code></pre><p>Here, we use <code>Array.isArray()</code><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> to see if the argument, <code>m</code>, is an <code>Array</code>, then we call a function, <code>mapArray</code>, that handles the <code>map</code>ping of the <code>Array</code>.</p><p><em>You might be thinking: why <code>m.map(x =&gt; fn(x))</code> and not <code>m.map(fn)</code>? As you might remember from <a href="https://robertwpearce.com/javascript-understand-array-prototype-map-by-reimplementing-it.html">my article on re-implementing <code>Array.prototype.map</code></a>, there are a few other arguments that the native implementation of <code>map</code> provide, as well as some potential changes to the <code>this</code> keyword in your callback function scope. Instead of allowing those to pass through, we simply take the first argument, the currently iterated value, and send that to the callback function<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</em></p><p>Now that we’ve seen the easy way to do <code>map</code> with <code>Array</code>, let’s see what this would look like if we felt like implementing <code>mapArray</code> ourselves:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapArray</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">newArray</span> <span class="pl-o">=</span> <span class="pl-p">[]</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">for</span> <span class="pl-p">(</span><span class="pl-kd">let</span> <span class="pl-nx">i</span> <span class="pl-o">=</span> <span class="pl-mi">0</span><span class="pl-p">;</span> <span class="pl-nx">i</span> <span class="pl-o">&lt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">length</span><span class="pl-p">;</span> <span class="pl-nx">i</span><span class="pl-o">++</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">newArray</span><span class="pl-p">[</span><span class="pl-nx">i</span><span class="pl-p">]</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">[</span><span class="pl-nx">i</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">newArray</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span></span></span></code></pre><p>Not too shabby! All we do is create a new <code>Array</code> and set the results of calling the callback function with each item to its index in the new <code>Array</code> and then return that <code>Array</code>.</p><p>Do you think our <code>map</code> function can handle an <code>Array</code> of <code>Array</code>s?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span><span class="pl-p">)([</span> <span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">],</span> <span class="pl-p">[</span><span class="pl-mi">3</span><span class="pl-p">,</span><span class="pl-mi">4</span><span class="pl-p">],</span> <span class="pl-p">[</span><span class="pl-mi">5</span><span class="pl-p">,</span><span class="pl-mi">6</span><span class="pl-p">]</span> <span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// Array(3) [ NaN, NaN, NaN ]
</span></span></span></code></pre><p>While we can successfully iterate over the 3 items in the top-level <code>Array</code>, our callback function can’t perform operations like <code>[1,2] * 2</code>! We need to do another <code>map</code> on the nested <code>Array</code>s:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span><span class="pl-p">))([</span> <span class="pl-p">[</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">],</span> <span class="pl-p">[</span><span class="pl-mi">3</span><span class="pl-p">,</span><span class="pl-mi">4</span><span class="pl-p">],</span> <span class="pl-p">[</span><span class="pl-mi">5</span><span class="pl-p">,</span><span class="pl-mi">6</span><span class="pl-p">]</span> <span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// [ [2,4], [6,8], [10,12] ]
</span></span></span></code></pre><p>Well done! What else can you <code>map</code>? We’re now going to leave charted waters and venture into the unknown.</p><h2 id="map-an-object"><code>map</code> an <code>Object</code></h2><p>Let’s say we have an <code>i18n</code> (short for “internationalization”) object that we’ve been given that has a terribly annoying issue: every translation is prefixed and suffixed with an underscore (<code>_</code>)!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">i18n</span> <span class="pl-o">=</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s1">'en-US'</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">dayMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Day mode_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">greeting</span><span class="pl-o">:</span> <span class="pl-s1">'_Hello!_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">nightMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Night Mode_'</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s1">'es-ES'</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">dayMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Modo día_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">greeting</span><span class="pl-o">:</span> <span class="pl-s1">'_¡Hola!_'</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">nightMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Modo nocturno_'</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span></span></span></code></pre><p>We could manually delete each one, or we could find and replace with our text editor, or we could write a <code>for</code> loop to do this, but because we’re super awesome functional programmers, we’ll try to <code>map</code> over the <code>Object</code> and write a function that removes the prefixed &amp; suffixed underscores (…then we copy and paste that? work with me here!).</p><p>Before we can do this, we need to see what happens when we call <code>.map()</code> on an <code>Object</code>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">i18n</span><span class="pl-p">[</span><span class="pl-s1">'en-US'</span><span class="pl-p">].</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// TypeError: i18n['en-US'].map is not a function
</span></span></span></code></pre><p>Oh no! If we can’t even fix the <code>en-US</code> <code>Object</code>, how are we supposed to fix <em>all</em> of them? Let’s update our <code>map</code> function to handle <code>Object</code>s.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapArray</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isObject</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapObject</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isObject :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isObject</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-o">!!</span><span class="pl-nx">x</span> <span class="pl-o">&amp;&amp;</span> <span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-s1">'[object Object]'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapObject :: ((a -&gt; b), { k: a }) -&gt; { k: b }
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapObject</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">obj</span> <span class="pl-o">=</span> <span class="pl-p">{}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">for</span> <span class="pl-p">(</span><span class="pl-kr">const</span> <span class="pl-p">[</span><span class="pl-nx">k</span><span class="pl-p">,</span> <span class="pl-nx">v</span><span class="pl-p">]</span> <span class="pl-k">of</span> <span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">entries</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">obj</span><span class="pl-p">[</span><span class="pl-nx">k</span><span class="pl-p">]</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">v</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">obj</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span></span></span></code></pre><p>Here, we test if something is an object by using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString</code></a> and make sure to <code>.call(x)</code> instead of just <code>.toString(x)</code>, for this reason:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// "[object Object]"
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// "[object Null]"
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">([])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// "[object Object]"
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">([])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// "[object Array]"
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">({})</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// "[object Object]"
</span></span></span></code></pre><p>We then use our new <code>mapObject</code> function, whose signature is</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">mapObject</span> <span class="pl-ow">::</span> <span class="pl-p">((</span><span class="pl-n">a</span> <span class="pl-ow">-&gt;</span> <span class="pl-n">b</span><span class="pl-p">),</span> <span class="pl-p">{</span> <span class="pl-n">k</span><span class="pl-kt">:</span> <span class="pl-n">a</span> <span class="pl-p">})</span> <span class="pl-ow">-&gt;</span> <span class="pl-p">{</span> <span class="pl-n">k</span><span class="pl-kt">:</span> <span class="pl-n">b</span> <span class="pl-p">}</span></span></span></code></pre><p><code>mapObject</code> takes a function from <code>a</code> to <code>b</code> and an <code>Object</code> with a key(s) and some value(s), <code>a</code>, and returns an <code>Object</code> with a key(s) and some value(s) <code>b</code>. In short, it maps the <em>values</em> of an <code>Object</code>. Our <code>mapObject</code> function is nothing more than a <code>for</code> loop over each value returned from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries()</code></a>! It calls the callback function with each value and returns a new object with the same key and a new, updated value.</p><p>Let’s try it out:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">i18n</span> <span class="pl-o">=</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s1">'en-US'</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">dayMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Day mode_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">greeting</span><span class="pl-o">:</span> <span class="pl-s1">'_Hello!_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">nightMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Night Mode_'</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s1">'es-ES'</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">dayMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Modo día_'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">greeting</span><span class="pl-o">:</span> <span class="pl-s1">'_¡Hola!_'</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">nightMode</span><span class="pl-o">:</span> <span class="pl-s1">'_Modo nocturno_'</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">,</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">))(</span><span class="pl-nx">i18n</span><span class="pl-p">[</span><span class="pl-s1">'en-US'</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// {
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   dayMode: 'Day mode',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   greeting: 'Hello!',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   nightMode: 'Night Mode'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// }
</span></span></span></code></pre><p>Okay – what about our entire <code>i18n</code> object?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">,</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">)))(</span><span class="pl-nx">i18n</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// {
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//  'en-US': {
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    dayMode: 'Day mode',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    greeting: 'Hello!',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    nightMode: 'Night Mode'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//  },
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//  'es-ES': {
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    dayMode: 'Modo día',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    greeting: '¡Hola!',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    nightMode: 'Modo nocturno'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//  }
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// }
</span></span></span></code></pre><p>Since we’re dealing with nested objects, we need to use <code>map</code> on an <code>Object</code> inside an <code>Object</code>. We pass a nested <code>map</code>ping function, and our little underscore problem is gone!</p><h2 id="map-a-function"><code>map</code> a <code>Function</code></h2><p>Remember our functions <code>mult2</code> and <code>add10</code> from before?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">add10</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">+</span> <span class="pl-mi">10</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">mult2</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span></span></span></code></pre><p>What would happen if we used those as the arguments to our <code>map</code> function and wanted them to be automatically composed together so that we can then provide a value later?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">)(</span><span class="pl-nx">mult2</span><span class="pl-p">)</span>     <span class="pl-c1">// undefined
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">)(</span><span class="pl-nx">mult2</span><span class="pl-p">)(</span><span class="pl-mi">12</span><span class="pl-p">)</span> <span class="pl-c1">// TypeError: map(...)(...) is not a function
</span></span></span></code></pre><p>Time for our <code>map</code> function to handle a <code>Function</code> as the second argument and <code>compose</code> the two functions together:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapArray</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isObject</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapObj</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isFunction :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isFunction</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-k">typeof</span> <span class="pl-nx">x</span> <span class="pl-o">===</span> <span class="pl-s1">'function'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// compose :: ((b -&gt; c), (a -&gt; b)) -&gt; a -&gt; c
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">compose</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">f</span><span class="pl-p">,</span> <span class="pl-nx">g</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">f</span><span class="pl-p">(</span><span class="pl-nx">g</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">))</span></span></span></code></pre><p>And when we run our previously failed code again,</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">)(</span><span class="pl-nx">mult2</span><span class="pl-p">)</span>     <span class="pl-c1">// function compose(x)
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">add10</span><span class="pl-p">)(</span><span class="pl-nx">mult2</span><span class="pl-p">)(</span><span class="pl-mi">12</span><span class="pl-p">)</span> <span class="pl-c1">// 44
</span></span></span></code></pre><p>we can see that calling <code>map</code> with two functions returns a composition of those two functions, and calling that result with a primitive value (<code>12</code>) gives us back our result, <code>44</code>.</p><h2 id="map-a-functor"><code>map</code> a <code>Functor</code></h2><p>When we learned about <code>map</code>ping <code>Array</code>s before, we learned that <code>Array</code>s are <code>Functor</code>s because they adhere to the laws of <em>identity</em> and <em>composition</em>; i.e., they are <code>map</code>pable.</p><p>There are all sorts of other data structures that implement a <code>map</code> method, just like <code>Array.prototype</code> does, and we want to be able to handle those, too!</p><p>We currently have all the tools required to implement <code>map</code> for <code>Functor</code>s without even knowing how they might work! All we need to know is, “Does it implement <code>map</code> as a <code>Function</code>?” Let’s see what we can come up with!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapArray</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isFunctor</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapFunctor</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isObject</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapObj</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isFunction :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isFunction</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-k">typeof</span> <span class="pl-nx">x</span> <span class="pl-o">===</span> <span class="pl-s1">'function'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isFunctor :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isFunctor</span>  <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-o">!!</span><span class="pl-nx">x</span> <span class="pl-o">&amp;&amp;</span> <span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">[</span><span class="pl-s1">'map'</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapFunctor</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">)</span></span></span></code></pre><p>That is surprisingly simple, isn’t it? We use our <code>isFunction</code> check from before to test if <code>m</code> has a <code>map</code> property that is a <code>Function</code>, then we call <code>map</code> on <code>m</code> and pass it the callback <code>Function</code> in <code>mapFunctor</code>.</p><p>You might be thinking that <code>mapArray</code> and <code>mapFunctor</code> could use the same handler because <code>Array</code>s are <code>Functors</code>, and you are correct; however, because of the extra implementation bits that come back from <code>Array.prototype.map</code>, we’ll keep them separate and only call the callback to <code>Array.prototype.map</code> with the currently iterated item. Here’s the difference:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapArray</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapFunctor</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">)</span></span></span></code></pre><p>If you don’t care about this, it’s totally acceptable to not include the <code>Array</code> bits at all and use the <code>Functor</code> <code>map</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> to handle the <code>map</code>ping of <code>Array</code>s, since they’re <code>Functor</code>s.</p><p>To test our <code>Functor</code> <code>map</code>ping, we’ll use <a href="https://crocks.dev">crocks</a> to provide us access to an algebraic data type called <a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a>.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-p">{</span> <span class="pl-nx">compose</span><span class="pl-p">,</span> <span class="pl-nx">option</span><span class="pl-p">,</span> <span class="pl-nx">prop</span> <span class="pl-p">}</span> <span class="pl-nx">from</span> <span class="pl-s1">'crocks'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">company</span> <span class="pl-o">=</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Pearce Software, LLC'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">locations</span><span class="pl-o">:</span> <span class="pl-p">[</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-s1">'Charleston, SC, USA'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-s1">'Auckland, NZ'</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-s1">'London, England, UK'</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'foo'</span><span class="pl-p">,</span> <span class="pl-nx">company</span><span class="pl-p">)</span>       <span class="pl-c1">// Nothing
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'locations'</span><span class="pl-p">,</span> <span class="pl-nx">company</span><span class="pl-p">)</span> <span class="pl-c1">// Just [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">option</span><span class="pl-p">([],</span> <span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'foo'</span><span class="pl-p">,</span> <span class="pl-nx">company</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// []
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">option</span><span class="pl-p">([],</span> <span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'locations'</span><span class="pl-p">,</span> <span class="pl-nx">company</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// [
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'Charleston, SC, USA',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'Auckland, NZ',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'London, England, UK'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// ]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">getLocations</span> <span class="pl-o">=</span> <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">option</span><span class="pl-p">([]),</span> <span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'locations'</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getLocations</span><span class="pl-p">(</span><span class="pl-nx">company</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// [
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'Charleston, SC, USA',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'Auckland, NZ',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'London, England, UK'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// ]
</span></span></span></code></pre><p>Pump the breaks! What’s all this <code>Just</code> and <code>Nothing</code> stuff? We’re not going to focus on <code>Maybe</code>s today<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, but the short version is that the <code>locations</code> property <em>may</em> or <em>may not</em> be present in the object, so we encapsulate that uncertainty inside of a <code>Maybe</code> algebraic data type via the <code>prop</code> function, and we provide a default value via the <code>option</code> function that the <code>Maybe</code> can fall back to in the event of not being able to find <code>locations</code>.</p><p>Why does this matter? We want to <code>map</code> a <code>Maybe</code>, and the <code>prop</code> function will give us access to one. Let’s see what it looks like:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-p">{</span> <span class="pl-nx">compose</span><span class="pl-p">,</span> <span class="pl-nx">option</span><span class="pl-p">,</span> <span class="pl-nx">prop</span> <span class="pl-p">}</span> <span class="pl-nx">from</span> <span class="pl-s1">'crocks'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">upcase</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">toUpperCase</span><span class="pl-p">()</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">getLocations</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">option</span><span class="pl-p">([]),</span> <span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">upcase</span><span class="pl-p">)),</span> <span class="pl-nx">prop</span><span class="pl-p">(</span><span class="pl-s1">'locations'</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getLocations</span><span class="pl-p">({})</span> <span class="pl-c1">// []
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getLocations</span><span class="pl-p">(</span><span class="pl-nx">company</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// [
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'CHARLESTON, SC, USA',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'AUCKLAND, NZ',
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   'LONDON, ENGLAND, UK'
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// ]
</span></span></span></code></pre><p>Okay, cool! But why are we <code>map</code>ping twice?</p><p>When we work with algebraic data types like <code>Maybe</code>, instead of writing <code>if (dataIsValid) doSomething</code>, the <code>map</code> method on a <code>Maybe</code> gives us access to the value inside the <code>Maybe</code> (our <code>locations</code>), but it does so <em>only if the data is available</em>.</p><p>Once we have access to the <code>locations</code>, we then use <code>map</code> again to uppercase each location.</p><h2 id="throwing-out-bad-data"><code>throw</code>ing Out Bad Data</h2><p>What happens if the arguments passed to <code>map</code> aren’t a <code>Function</code> and a <code>Functor</code>?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)([</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">])</span>    <span class="pl-c1">// TypeError: fn is not a function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span><span class="pl-p">)(</span><span class="pl-kc">null</span><span class="pl-p">)</span> <span class="pl-c1">// undefined
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)(</span><span class="pl-kc">null</span><span class="pl-p">)</span>       <span class="pl-c1">// undefined
</span></span></span></code></pre><p>I think we can provide some more helpful messaging to guide users of our <code>map</code> tool on how to use it correctly.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-o">!</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-nx">TypeError</span><span class="pl-p">(</span><span class="pl-sb">`map: Please provide a Function for the first argument`</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// ...our other handlers...
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-nx">TypeError</span><span class="pl-p">(</span><span class="pl-sb">`map: Please provide a Functor or Object for the second argument`</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)([</span><span class="pl-mi">1</span><span class="pl-p">,</span><span class="pl-mi">2</span><span class="pl-p">,</span><span class="pl-mi">3</span><span class="pl-p">])</span>    <span class="pl-c1">// TypeError: map: Please provide a Function for the first argument
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span> <span class="pl-o">*</span> <span class="pl-mi">2</span><span class="pl-p">)(</span><span class="pl-kc">null</span><span class="pl-p">)</span> <span class="pl-c1">// TypeError: map: Please provide a Functor or Object for the second argument
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">)(</span><span class="pl-kc">null</span><span class="pl-p">)</span>       <span class="pl-c1">// TypeError: map: Please provide a Function for the first argument
</span></span></span></code></pre><p>Now, when we provide bad arguments, we’re told exactly what we need to do.</p><h2 id="wrapping-up">Wrapping Up</h2><p>Congratulations and thank you for making it to the end! If you want to play around with what we created, check out this CodeSandbox: <a href="https://codesandbox.io/s/bitter-grass-tknwb" class="uri">https://codesandbox.io/s/bitter-grass-tknwb</a>.</p><p>Here is our code from today in its entirety:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-p">{</span> <span class="pl-nx">compose</span><span class="pl-p">,</span> <span class="pl-nx">option</span><span class="pl-p">,</span> <span class="pl-nx">prop</span> <span class="pl-p">}</span> <span class="pl-o">=</span> <span class="pl-nx">require</span><span class="pl-p">(</span><span class="pl-s1">'crocks'</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">map</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-o">!</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-nx">TypeError</span><span class="pl-p">(</span><span class="pl-sb">`map: Please provide a Function for the first argument`</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapArray</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isFunctor</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapFunctor</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">isObject</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">mapObj</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-nx">TypeError</span><span class="pl-p">(</span><span class="pl-sb">`map: Please provide a Functor or Object for the second argument`</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// we're opting for crocks' compose, instead
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// compose :: ((b -&gt; c), (a -&gt; b)) -&gt; a -&gt; c
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// const compose = (f, g) =&gt; x =&gt; f(g(x))
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isArray :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isArray</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">isArray</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isFunction :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isFunction</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-k">typeof</span> <span class="pl-nx">x</span> <span class="pl-o">===</span> <span class="pl-s1">'function'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isFunctor :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isFunctor</span>  <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-o">!!</span><span class="pl-nx">x</span> <span class="pl-o">&amp;&amp;</span> <span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">[</span><span class="pl-s1">'map'</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// isObject :: a -&gt; Bool
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">isObject</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-o">!!</span><span class="pl-nx">x</span> <span class="pl-o">&amp;&amp;</span> <span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">toString</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-s1">'[object Object]'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapArray</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">newArray</span> <span class="pl-o">=</span> <span class="pl-p">[]</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">for</span> <span class="pl-p">(</span><span class="pl-kd">let</span> <span class="pl-nx">i</span> <span class="pl-o">=</span> <span class="pl-mi">0</span><span class="pl-p">;</span> <span class="pl-nx">i</span> <span class="pl-o">&lt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">length</span><span class="pl-p">;</span> <span class="pl-nx">i</span><span class="pl-o">++</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">newArray</span><span class="pl-p">.</span><span class="pl-nx">push</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">[</span><span class="pl-nx">i</span><span class="pl-p">]))</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">newArray</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// realistically, you should use this mapArray:
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// const mapArray = (fn, m) =&gt; m.map(x =&gt; fn(x))
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapObj :: (a -&gt; b) -&gt; { k: a } -&gt; { k: b }
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapObj</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">obj</span> <span class="pl-o">=</span> <span class="pl-p">{}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">for</span> <span class="pl-p">(</span><span class="pl-kr">const</span> <span class="pl-p">[</span><span class="pl-nx">k</span><span class="pl-p">,</span> <span class="pl-nx">v</span><span class="pl-p">]</span> <span class="pl-k">of</span> <span class="pl-nb">Object</span><span class="pl-p">.</span><span class="pl-nx">entries</span><span class="pl-p">(</span><span class="pl-nx">m</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">obj</span><span class="pl-p">[</span><span class="pl-nx">k</span><span class="pl-p">]</span> <span class="pl-o">=</span> <span class="pl-nx">fn</span><span class="pl-p">(</span><span class="pl-nx">v</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">obj</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapFunctor</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">m</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">m</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">)</span></span></span></code></pre><hr /><p>Thank you for reading! <br /> Robert</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr /><ol><li id="fn1"><p><a href="https://github.com/hemanth/functional-programming-jargon#algebraic-data-type" class="uri">https://github.com/hemanth/functional-programming-jargon#algebraic-data-type</a>  <a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><code>m</code> for <a href="https://github.com/hemanth/functional-programming-jargon#monoid"><code>Monoid</code></a>  <a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>Wondering why the data comes last? Check out <a href="https://youtu.be/m3svKOdZijA">Brian Lonsdorf’s “Hey Underscore, You’re Doing It Wrong!” talk</a>. The tl;dr is that you should arrange your arguments from least likely to change to most likely to change in order to pave the way for partial application and greater code reuse.  <a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://github.com/hemanth/functional-programming-jargon#arity" class="uri">https://github.com/hemanth/functional-programming-jargon#arity</a>  <a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p><a href="https://github.com/hemanth/functional-programming-jargon#functor" class="uri">https://github.com/hemanth/functional-programming-jargon#functor</a>  <a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" class="uri">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray</a>  <a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>Check out <a href="https://ramdajs.com/docs/#addIndex">ramda.js’ <code>addIndex</code> function</a> to see a different pattern for working with indices and <code>Array</code>s.  <a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p><code>Functor</code> <code>map</code> is also known as <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class"><code>fmap</code></a>.  <a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>If you’re an <a href="https://egghead.io">egghead.io</a> subscriber, <a href="https://twitter.com/avanslaars/">Andy Van Slaars</a> has a great course, <a href="https://egghead.io/courses/safer-javascript-with-the-maybe-type">Safer JavaScript with the Maybe Type</a>, or you can check out <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class">a Haskell article on The Functor class</a>.  <a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section></section></main><footer><span aria-hidden="true" class="heart">♥</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">♥</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>