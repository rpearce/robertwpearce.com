<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Simple Variadic Behavior</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
    <meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU">
    <meta name="description" content="undefined">

    <meta property="og:site_name" content="RobertWPearce.com">
    <meta property="og:url" content="http://robertwpearce.com">
    <meta property="og:description" content="undefined">
    <meta property="og:image" content="">
    <meta property="og:type" content="article">

    <link href="http://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/app.css">
    <!--<link rel="canonical" href="http://www.robertwpearce.com/">-->
    <!--<link rel="alternate" type="application/rss+xml" title="Robert W. Pearce" href="http://robertwpearce.com/feed.xml">-->
  </head>
  <body>
    <nav class="align--center">
      <ul class="nav--main list--bare">
        <li><a href="/">Home</a></li>
        <li><a href="/hire-me.html">Hire Me</a></li>
        <li><a href="/blog/index.html">Blog</a></li>
      </ul>
    </nav>

    <article class="article">
      <div class="article-background" style="background-image: url(http://s3.amazonaws.com/rpearce.github.io/variadic/waterfall.jpg)">
        <div class="overlay"></div>
        <div class="layout-constrained">
          <div class="article-background-header">
            <h1 class="is-first">
              <a href="">Simple Variadic Behavior</a>
            </h1>
            <small><em>Oct 13, 2015</em></small>
          </div>
        </div>
      </div>
      <div class="layout-constrained">
<p>Recently, I have started working on my own static site generator, <a href="https://github.com/rpearce/statik-js">statik-js</a>, to accomodate my markdown blog posting &amp; static site needs. Another benefit is that I get to work on my Node.js and ES2015+ JavaScript skills. While I am reinventing the wheel on some levels, it is good practice.</p>
<p>My latest problem to solve was how, once I had a <code>.md</code> (Markdown) file&#39;s contents, to go about parsing out the blog post&#39;s metadata (see below: the key/value pairs between the two <code>---</code>s).</p>
<pre><code>---
title: This is a test
description: Once upon a time, there was a test...
---

# Title of my great post
Lorem ipsum dolor...

## Some heading
Bacon ipsum...
</code></pre><p>Once I <code>split</code> this file based on newlines, I needed a way of finding the indices of the metadata boundary, <code>---</code>, so that I could <code>splice</code> the array in to two pieces and be on my way. My first attempt at getting the indices looked like this:</p>
<pre><code class="lang-js">function getMetadataIndices(lines) {
var arr = [];
lines.forEach((line, i) =&gt; {
if (/^---/.test(line)) {
arr.push(i);
}
});
return arr;
}

getMetadataIndices(lines); // [0, 3]
</code></pre>
<p>This is a simple solution that any junior dev can do, and it accomplishes the task... but it doesn&#39;t feel right. I am iterating over each item, testing each line and mutating an array variable when a condition is true. While it doesn&#39;t look like much, that is a good bit going on all at once. Instinct tells me that each action could be its own simple method. I also don&#39;t want to use a temporary variable that I mutate. However, this removes <code>forEach</code> from our options, as <code>forEach</code> returns the original array. <code>map()</code> to the rescue! (or so we think).</p>
<pre><code class="lang-js">function getMetadataIndices(lines) {
return lines.map(testForBoundary);
}

function testForBoundary(item, i) {
if (/^---/.test(item)) {
return i;
}
}

getMetadataIndices(lines); // [0, undefined, undefined, 3, undefined, undefined, undefined, undefined, undefined, undefined]
</code></pre>
<p>Crap. Because I only return when the test is true, <code>map</code> doesn&#39;t know what to return, so it returns <code>undefined</code> and moves on. It would be nice if we could clean out these <code>undefined</code>s!</p>
<h2 id="cleaning-up-our-array">Cleaning Up Our Array</h2>
<p>How can we achieve the following desired functionality?</p>
<pre><code class="lang-js">function getMetadataIndices(lines) {
return lines.map(testForBoundary).clean(undefined);
}

getMetadataIndices(lines); // [0, 3]
</code></pre>
<p>Let&#39;s make a function on the <code>prototype</code> of <code>Array</code> called <code>clean</code>:</p>
<pre><code class="lang-js">Array.prototype.clean = function(trash) {
};
</code></pre>
<p>Here, we access <code>Array</code>&#39;s <code>prorotype</code> and add our own custom method, <code>clean</code> and pass it one argument. Next, we need to <code>filter</code> out all of the <code>undefined</code>s in our array.</p>
<pre><code class="lang-js">Array.prototype.clean = function(trash) {
return this.filter(item =&gt; item !== trash);
};
</code></pre>
<p>But what if we need to clean more than one value out? What if we need to clean <code>null</code>, <code>&quot;&quot;</code> and <code>undefined</code>?</p>
<h2 id="variadic-behavior">Variadic Behavior</h2>
<p>In JavaScript, <em>variadic behavior</em> is a fancy term applied to functions that can accept and handle any number of arguments, and these are typically accessed within the function via the <code>arguments</code> object, which looks like an <code>Array</code> but is <em>not</em>. For example, this code will give you an error about <code>indexOf</code> not being defined on <code>arguments</code>.</p>
<pre><code class="lang-js">Array.prototype.clean = function(trash) {
return this.filter(item =&gt; arguments.indexOf(item) === -1);
};
</code></pre>
<p>Drats! <code>arguments</code> is very similar to an array &mdash; how can we get this to work? <code>slice</code> to the rescue!</p>
<pre><code class="lang-js">Array.prototype.clean = function() {
const args = [].slice.call(arguments);
return this.filter(item =&gt; args.indexOf(item) === -1);
};
</code></pre>
<p>Without any additional arguments, <code>slice</code> makes a copy of an array and allows us to provide a custom receiver of array-like functionality: <code>arguments</code>. What is returned from the second line above is an array-ized <em>copy</em> of <code>arguments</code>. Now that <code>args</code> is an array of all the arguments that are passed to <code>clean</code>, we can pass as many options as we would like to clean out our array!</p>
<p>Here is more example usage of such a method:</p>
<pre><code class="lang-js">// Usage
const arr = [&quot;&quot;, undefined, 3, &quot;yes&quot;, undefined, undefined, &quot;&quot;];
arr.clean(undefined); // [&quot;&quot;, 3, &quot;yes&quot;, &quot;&quot;];
arr.clean(undefined, &quot;&quot;); // [3, &quot;yes&quot;];
</code></pre>
<h2 id="all-together">All Together</h2>
<p>In attempting to refactor some fairly simple, though multiple-responsibility code, we end up creating a few reusable functions that will benefit us in the future, and we make our code more maintainable, testable and readable in the end. Here it is once we have finished:</p>
<pre><code class="lang-js">function getMetadataIndices(lines) {
return lines.map(testForBoundary).clean(undefined);
}

function testForBoundary(item, i) {
if (/^---/.test(item)) {
return i;
}
}

Array.prototype.clean = function() {
const args = [].slice.call(arguments);
return this.filter(item =&gt; args.indexOf(item) === -1);
};
</code></pre>
<p>But could this be done <em>even</em> simpler?</p>
<h2 id="p-s-use-reduce-next-time">p.s. Use reduce next time</h2>
<p>You may have been wondering why we didn&#39;t use <code>reduce</code> like this from the start:</p>
<pre><code class="lang-js">lines.reduce(function(mem, item, i) {
if (/^---/.test(item)) {
mem.push(i);
}
return mem;
});
</code></pre>
<p>or, cleaned up a bit,</p>
<pre><code class="lang-js">function getMetadataIndices(mem, item, i) {
if (/^---/.test(item)) {
mem.push(i);
}
return mem;
}

lines.reduce(getMetadataIndices, []);
</code></pre>
<p>Surprise! We totally could have, but since <code>reduce</code> was not our first thought when refactoring, we managed to solve our problem in another way. There are 1000 ways to solve problems, and sometimes you don&#39;t think of the best one first, but you can still make the best with what you have at the time and refactor later.</p>
      </div>
    </article>
  </body>
</html>

