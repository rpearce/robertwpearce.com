<!DOCTYPE html><html lang="en"><head><title>Hakyll Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Leverage hakyll's own internals to output custom webpage URI routes using any metdata field â€“ in this case, our post title."><meta name="author" content="Robert Pearce"><meta name="keywords" content="hakyll, slug, filename, hakyll tutorial, hakyll blog, hakyll blog tutorial, hakyll static site, static site generator"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="Hakyll Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug"><meta property="og:url" content="https://robertwpearce.com/hakyll-pt-5-generating-custom-post-filenames-from-a-title-slug.html"><meta property="og:description" content="Leverage hakyll's own internals to output custom webpage URI routes using any metdata field â€“ in this case, our post title."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="Hakyll Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug"><meta property="twitter:description" content="Leverage hakyll's own internals to output custom webpage URI routes using any metdata field â€“ in this case, our post title."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ’¾</text></svg>"><link rel="canonical" href="https://robertwpearce.com/hakyll-pt-5-generating-custom-post-filenames-from-a-title-slug.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>Hakyll Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>Leverage hakyll's own internals to output custom webpage URI routes using any metdata field â€“ in this case, our post title.</td></tr><tr><th>Shared</th><td>2019-03-16</td></tr><tr><th>Revised</th><td>2023-02-11 @ 16:00 UTC</td></tr></tbody></table></section><section data-area="note"><p><em>2023-02-03 update: I published the <a href="https://hackage.haskell.org/package/slugger">slugger</a> package on Hackage back on 2021-07-28, so that is available for use if youâ€™d rather use a package.</em></p><p>This is part 5 of a multipart series where we will look at getting a website / blog set up with <a href="https://jaspervdj.be/hakyll">hakyll</a> and customized a fair bit.</p><ul><li><a href="/hakyll-pt-1-setup-initial-customization.html">Pt. 1 â€“ Setup &amp; Initial Customization</a></li><li><a href="/hakyll-pt-2-generating-a-sitemap-xml-file.html">Pt. 2 â€“ Generating a Sitemap XML File</a></li><li><a href="/hakyll-pt-3-generating-rss-and-atom-xml-feeds.html">Pt. 3 â€“ Generating RSS and Atom XML Feeds</a></li><li><a href="/hakyll-pt-4-copying-static-files-for-your-build.html">Pt. 4 â€“ Copying Static Files For Your Build</a></li><li>Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug</li><li><a href="/hakyll-pt-6-pure-builds-with-nix.html">Pt. 6 â€“ Pure Builds With Nix</a></li><li><a href="/the-hakyll-nix-template-tutorial.html">The hakyll-nix-template Tutorial</a></li></ul><h2 id="overview">Overview</h2><p>Out of the box, hakyll takes filenames and dates and outputs nice routes for your webpages, but what if you want your routes to be based off of a metadata field like <code>title</code>? In this post weâ€™ll take a title like <code>"Hakyll Pt. 5 â€“ Generating Custom Post Filenames From a Title Slug"</code> and have hakyll output routes like <code>"hakyll-pt-5-generating-custom-post-filenames-from-a-title-slug"</code>.</p><ol><li><a href="#where-do-we-start-hakylls-route-function">Where Do We Start? Hakyllâ€™s <code>route</code> Function</a></li><li><a href="#looking-to-idroute-setextension-and-other-routes-functions-for-clues">Looking to <code>idRoute</code>, <code>setExtension</code> and Other <code>Routes</code> Functions for Clues</a></li><li><a href="#leveraging-hakylls-metadataroute-to-access-title-metadata">Leveraging Hakyllâ€™s <code>metadataRoute</code> to Access Title Metadata</a></li><li><a href="#writing-our-own-uri-slug-function">Writing Our Own URI Slug Function</a></li><li><a href="#retrieving-and-slugifying-our-titles">Retrieving and Slugifying our Titles</a></li></ol><h2 id="where-do-we-start-hakylls-route-function">Where Do We Start? Hakyllâ€™s <code>route</code> Function</h2><p>In <a href="https://jaspervdj.be/hakyll/tutorials/03-rules-routes-compilers.html#basic-routes">the hakyll tutorial on basic routing</a>, as well as other posts in this series, we have come across hakyllâ€™s <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Rules.hs#L175"><code>route</code></a> function used in conjunction with functions like <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L114-L115"><code>idRoute</code></a> and <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L136-L138"><code>setExtension</code></a>. Given these functions live in the <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs"><code>Hakyll.Core.Routes</code></a> module, we can bet that other functions for customizing our outputted routes will be found in there. Letâ€™s see what we can find!</p><h2 id="looking-to-idroute-setextension-and-other-routes-functions-for-clues">Looking to <code>idRoute</code>, <code>setExtension</code> and Other <code>Routes</code> Functions for Clues</h2><p>When we look at <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs"><code>Hakyll.Core.Routes</code></a>, we can see that <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L114-L115"><code>idRoute</code></a> and <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L136-L138"><code>setExtension</code></a>, which we know are used with <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Rules.hs#L175"><code>route</code></a>, both return a type of <code>Routes</code>. The implementation of <code>Routes</code> is not important for us here, for our job now is to see what <em>other</em> functions return <code>Routes</code>, as well, so that we can potentially leverage their functionality.</p><p>Doing a quick search in that module reveals to us some very interesting results! * <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L152-L153"><code>customRoute</code></a> * <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L159-L160"><code>constRoute</code></a> * <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L173-L177"><code>gsubRoute</code></a> * <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Routes.hs#L182-L185"><code>metadataRoute</code></a></p><p>Alright! Now, what does each one do? * <code>customRoute</code>: takes in a function that accepts an <code>Identifier</code> and returns a <code>FilePath</code> and returns that. Sounds like it could be useful, somehowâ€¦ Letâ€™s keep going. * <code>constRoute</code>: takes in a <code>FilePath</code>, wraps the value in a <code>const</code> function (which will always return the value it was passed) and then passes the function to <code>customRoute</code>! Okay, so this basically means if we say <code>constRoute "foo.html"</code>, then thatâ€™s what the route will come out as. Makes sense. * <code>gsubRoute</code>: this oneâ€™s purpose is to use patterns to replace parts of routes (like transforming <code>"tags/rss/bar.xml"</code> to <code>tags/bar.xml</code>). Useful! But not for our task. * <code>metadataRoute</code>: takes in a function that accepts <code>Metadata</code> and returns <code>Routes</code>, and then this function returns <code>Routes</code>. Since we want to access our <code>title</code> metadata to create a route, something that gives us access to <code>Metadata</code> and returns <code>Routes</code> is exactly what we want!</p><h2 id="leveraging-hakylls-metadataroute-to-access-title-metadata">Leveraging Hakyllâ€™s <code>metadataRoute</code> to Access Title Metadata</h2><p>As with most things in the Haskell world, letâ€™s allow the types to guide us. What do we know? * <code>route</code> accepts a function whose return value is <code>Routes</code> * <code>metadataRoute</code> ultimately returns <code>Routes</code> (yay!), but it first takes in a function that accepts <code>Metadata</code> and needs to return <code>Routes</code>.</p><p>Therefore, our task is to write a function with the signature <code>Metadata -&gt; Routes</code> that finds the <code>title</code> field in the metadata, converts it to a URI slug, and transforms that <code>FilePath</code> into a <code>Routes</code>. Perhaps we could call it <code>titleRoute</code> and then extract the conversion from <code>Metadata</code> to <code>FilePath</code> to something like <code>fileNameFromTitle</code>? Good enough.</p><p>Also, what did we see earlier that can take a <code>FilePath</code> and return <code>Routes</code>? <code>constRoute</code> to the rescue! With these initial bits figured out, letâ€™s sketch this out :</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">main</span> <span class="pl-ow">::</span> <span class="pl-kt">IO</span> <span class="pl-nb">()</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">main</span> <span class="pl-ow">=</span> <span class="pl-n">hakyllWith</span> <span class="pl-n">config</span> <span class="pl-o">$</span> <span class="pl-kr">do</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-n">match</span> <span class="pl-s">"posts/*"</span> <span class="pl-o">$</span> <span class="pl-kr">do</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kr">let</span> <span class="pl-n">ctx</span> <span class="pl-ow">=</span> <span class="pl-n">constField</span> <span class="pl-s">"type"</span> <span class="pl-s">"article"</span> <span class="pl-o">&lt;&gt;</span> <span class="pl-n">postCtx</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-n">route</span> <span class="pl-o">$</span> <span class="pl-n">metadataRoute</span> <span class="pl-n">titleRoute</span> <span class="pl-c1">-- THIS LINE</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-n">compile</span> <span class="pl-o">$</span> <span class="pl-n">pandocCompilerCustom</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-o">&gt;&gt;=</span> <span class="pl-n">loadAndApplyTemplate</span> <span class="pl-s">"templates/post.html"</span>    <span class="pl-n">ctx</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-o">&gt;&gt;=</span> <span class="pl-n">saveSnapshot</span> <span class="pl-s">"content"</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-o">&gt;&gt;=</span> <span class="pl-n">loadAndApplyTemplate</span> <span class="pl-s">"templates/default.html"</span> <span class="pl-n">ctx</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-c1">-- ...other rules</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">titleRoute</span> <span class="pl-ow">::</span> <span class="pl-kt">Metadata</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">Routes</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">titleRoute</span> <span class="pl-ow">=</span> <span class="pl-n">constRoute</span> <span class="pl-o">.</span> <span class="pl-n">fileNameFromTitle</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">fileNameFromTitle</span> <span class="pl-ow">::</span> <span class="pl-kt">Metadata</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">FilePath</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">fileNameFromTitle</span> <span class="pl-ow">=</span> <span class="pl-n">undefined</span> <span class="pl-c1">-- ???</span></span></span></code></pre><p>Great! This is progress! We have the outline of what we need to accomplish. The next task is to find the <code>title</code>, convert it to a slug and return a <code>FilePath</code>. But first, we need to take a detour and write a <code>toSlug</code> function that we can work with.</p><h2 id="writing-our-own-uri-slug-function">Writing Our Own URI Slug Function</h2><p>Taking inspiration from the archived project <a href="https://github.com/mrkkrp/slug" class="uri">https://github.com/mrkkrp/slug</a>, we can write a module, <code>Slug.hs</code>, with a main function, <code>toSlug</code> that takes in <code>Text</code> from <code>Data.Text</code> and transforms it from normal text to a slug. For example, <code>"This example isn't good"</code> would be transformed into <code>"this-example-isnt-good"</code>.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-cm">{-# LANGUAGE OverloadedStrings #-}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">module</span> <span class="pl-nn">Slug</span> <span class="pl-p">(</span><span class="pl-nf">toSlug</span><span class="pl-p">)</span> <span class="pl-kr">where</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span>           <span class="pl-nn">Data.Char</span> <span class="pl-p">(</span><span class="pl-nf">isAlphaNum</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-k">qualified</span> <span class="pl-nn">Data.Text</span> <span class="pl-k">as</span> <span class="pl-n">T</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">keepAlphaNum</span> <span class="pl-ow">::</span> <span class="pl-kt">Char</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">Char</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">keepAlphaNum</span> <span class="pl-n">x</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-o">|</span> <span class="pl-n">isAlphaNum</span> <span class="pl-n">x</span> <span class="pl-ow">=</span> <span class="pl-n">x</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-o">|</span> <span class="pl-n">otherwise</span>    <span class="pl-ow">=</span> <span class="pl-sc">' '</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">clean</span> <span class="pl-ow">::</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-kt">Text</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-kt">Text</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">clean</span> <span class="pl-ow">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">map</span> <span class="pl-n">keepAlphaNum</span> <span class="pl-o">.</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">replace</span> <span class="pl-s">"'"</span> <span class="pl-s">""</span> <span class="pl-o">.</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">replace</span> <span class="pl-s">"&amp;"</span> <span class="pl-s">"and"</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">toSlug</span> <span class="pl-ow">::</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-kt">Text</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-kt">Text</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">toSlug</span> <span class="pl-ow">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">intercalate</span> <span class="pl-p">(</span><span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">singleton</span> <span class="pl-sc">'-'</span><span class="pl-p">)</span> <span class="pl-o">.</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">words</span> <span class="pl-o">.</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">toLower</span> <span class="pl-o">.</span> <span class="pl-n">clean</span></span></span></code></pre><p>Once you do this, donâ€™t forget to open up your projectâ€™s <code>.cabal</code> file, add in this line and run <code>stack build</code> eventually:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">executable</span> <span class="pl-n">site</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">-- ...</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-n">other</span><span class="pl-o">-</span><span class="pl-n">modules</span><span class="pl-kt">:</span>    <span class="pl-kt">Slug</span></span></span></code></pre><p>Now that this is taken care of, letâ€™s return to the remaining task!</p><h2 id="retrieving-and-slugifying-our-titles">Retrieving and Slugifying our Titles</h2><p>The last step in our journey is to look up the <code>title</code> in the <code>Metadata</code>, convert it to a slug and return a <code>FilePath</code>. Letâ€™s look at the implementation and then talk about it:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nf">titleRoute</span> <span class="pl-ow">::</span> <span class="pl-kt">Metadata</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">Routes</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">titleRoute</span> <span class="pl-ow">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-n">constRoute</span> <span class="pl-o">.</span> <span class="pl-n">fileNameFromTitle</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">fileNameFromTitle</span> <span class="pl-ow">::</span> <span class="pl-kt">Metadata</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">FilePath</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">fileNameFromTitle</span> <span class="pl-ow">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">unpack</span> <span class="pl-o">.</span> <span class="pl-p">(`</span><span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">append</span><span class="pl-p">`</span> <span class="pl-s">".html"</span><span class="pl-p">)</span> <span class="pl-o">.</span> <span class="pl-n">toSlug</span> <span class="pl-o">.</span> <span class="pl-kt">T</span><span class="pl-o">.</span><span class="pl-n">pack</span> <span class="pl-o">.</span> <span class="pl-n">getTitleFromMeta</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">getTitleFromMeta</span> <span class="pl-ow">::</span> <span class="pl-kt">Metadata</span> <span class="pl-ow">-&gt;</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nf">getTitleFromMeta</span> <span class="pl-ow">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-n">fromMaybe</span> <span class="pl-s">"no title"</span> <span class="pl-o">.</span> <span class="pl-n">lookupString</span> <span class="pl-s">"title"</span></span></span></code></pre><ol><li><code>getTitleFromMeta</code>: use <code>Metadata</code>â€™s <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Metadata.hs#L36-L37"><code>lookupString</code></a> function to search for <code>title</code> and handle the <code>Maybe String</code> return value by providing a fallback of <code>"no title"</code></li><li><code>fileNameFromTitle</code>: once we get the <code>title</code> <code>String</code>, convert it to type <code>Text</code>, pass that to the slugify function, append <code>.html</code> to the slugified <code>title</code>, then convert it back to a <code>String</code> (<code>FilePath</code> is a type alias of <code>String</code>, so no worries here)</li><li><code>titleRoute</code>: once we have a <code>FilePath</code> value, we pass it to <code>constRoute</code> to get back our <code>Routes</code> type that <code>metadataRoute</code> requires, and weâ€™re done!</li></ol><h2 id="wrapping-up">Wrapping Up</h2><p>While it would be awesome if this sort of thing were built in to hakyll, this experience has shown me that in a way, the core of hakyll allows people to customize their build to their heartâ€™s delight, and perhaps an implementation such as this would be useful as a hakyll plugin. Maybe!</p><p>Next up: <a href="/hakyll-pt-6-pure-builds-with-nix.html">Pt. 6 â€“ Pure Builds With Nix</a></p><hr /><p>Thank you for reading! <br /> Robert</p></section></main><footer><span aria-hidden="true" class="heart">â™¥</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">â™¥</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>