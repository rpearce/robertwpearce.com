<!DOCTYPE html><html lang="en"><head><title>Ramda Chops: Function Composition</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Learn about function composition with ramda's compose function."><meta name="author" content="Robert Pearce"><meta name="keywords" content="ramda, ramda.js, ramdajs, ramda tutorial, ramda compose, function composition, ramda fp"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="Ramda Chops: Function Composition"><meta property="og:url" content="https://robertwpearce.com/ramda-chops-function-composition.html"><meta property="og:description" content="Learn about function composition with ramda's compose function."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="Ramda Chops: Function Composition"><meta property="twitter:description" content="Learn about function composition with ramda's compose function."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üíæ</text></svg>"><link rel="canonical" href="https://robertwpearce.com/ramda-chops-function-composition.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>Ramda Chops: Function Composition</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>Learn about function composition with ramda's compose function.</td></tr><tr><th>Shared</th><td>2018-01-26</td></tr><tr><th>Revised</th><td>2023-02-12 @ 18:00 UTC</td></tr></tbody></table></section><section data-area="note"><p><em>Thanks to <a href="https://twitter.com/evilsoft">@evilsoft</a> and <a href="https://twitter.com/zerkms">@zerkms</a> for their review of this post.</em></p><p><em>Composition</em> is defined as ‚Äúthe combining of distinct parts or elements to form a whole.‚Äù <sup><a href="https://www.wordnik.com/words/composition">source</a></sup> If we apply this thinking to functions in programming, then <em>function composition</em> can be seen as the combining of functions to form a new function that is <em>composed</em> of said functions. Now that that word salad is over, let‚Äôs get to work.</p><p>We have a task, and our task is to write a function that 1. accepts a list of objects containing <code>score</code> (<code>Number</code>) and <code>name</code> (<code>String</code>) properties 1. returns the top 3 scorers‚Äô names from highest to lowest</p><p>Here are the unordered results that we have to work with:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">results</span> <span class="pl-o">=</span> <span class="pl-p">[</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">40</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Aragorn'</span> <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">99</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Bilbo'</span> <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">63</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Celeborn'</span> <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">77</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Denethor'</span> <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">100</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Eowin'</span> <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">{</span> <span class="pl-nx">score</span><span class="pl-o">:</span> <span class="pl-mi">94</span><span class="pl-p">,</span> <span class="pl-nx">name</span><span class="pl-o">:</span> <span class="pl-s1">'Frodo'</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">]</span></span></span></code></pre><hr /><p><em>Other ramda posts:</em></p><ul><li><a href="/ramda-chops-function-currying.html">Ramda Chops: Function Currying</a></li><li><a href="/ramda-chops-safely-accessing-properties.html">Ramda Chops: Safely Accessing Properties</a></li><li><a href="/ramda-chops-map-filter-and-reduce.html">Ramda Chops: Map, Filter &amp; Reduce</a></li></ul><h2 id="first-approach">First Approach</h2><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getHighScorers :: [Object] -&gt; [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getHighScorers</span> <span class="pl-o">=</span> <span class="pl-nx">xs</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">[...</span><span class="pl-nx">xs</span><span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">.</span><span class="pl-nx">sort</span><span class="pl-p">((</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">b</span><span class="pl-p">.</span><span class="pl-nx">score</span> <span class="pl-o">-</span> <span class="pl-nx">a</span><span class="pl-p">.</span><span class="pl-nx">score</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">0</span><span class="pl-p">,</span> <span class="pl-mi">3</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">.</span><span class="pl-nx">name</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getHighScorers</span><span class="pl-p">(</span><span class="pl-nx">results</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; [ 'Eowin', 'Bilbo', 'Frodo' ]
</span></span></span></code></pre><p>As cautious JavaScript developers, we know to reach for our functions and methods that don‚Äôt mutate the objects we‚Äôre receiving. We use a <em>copy</em> of the original list and chain together operations that <code>sort</code>, <code>slice</code> and <code>map</code> the return values of each operation until we arrive at <code>[ 'Eowin', 'Bilbo', 'Frodo' ]</code>. Many folks would stop here, write a few unit tests and be done with it. We, on the other hand, will take this to the next level.</p><h2 id="extracting-reusable-functions">Extracting Reusable Functions</h2><p>Our <code>getHighScorers</code> function has some functionality that we may want to use elsewhere in the future. Let‚Äôs break down what we might be able to extract:</p><ul><li>a <em>sort by some prop in descending order</em> function (from <code>sort</code>)</li><li>a <em>take n items</em> function (from <code>slice</code>)</li><li>a <em>map prop</em> function (from <code>map</code>)</li></ul><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// Altered slightly to allows us to compare
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// things like strings and numbers.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// descBy :: (String, [a]) -&gt; [a]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">descBy</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">prop</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">[...</span><span class="pl-nx">xs</span><span class="pl-p">].</span><span class="pl-nx">sort</span><span class="pl-p">((</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">a</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">&lt;</span> <span class="pl-nx">b</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">?</span> <span class="pl-mi">1</span> <span class="pl-o">:</span> <span class="pl-p">(</span><span class="pl-nx">a</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">===</span> <span class="pl-nx">b</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">?</span> <span class="pl-mi">0</span> <span class="pl-o">:</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// takeN :: (Number, [a]) -&gt; [a]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">takeN</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">n</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">xs</span><span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">0</span><span class="pl-p">,</span> <span class="pl-nx">n</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapProp :: (String, [a]) -&gt; [b]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapProp</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">prop</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">xs</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// 1. pass `score` and `xs` to `descBy`
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// 2. pass the return value of `descBy`
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    to `takeN(3, __)`
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// 3. pass the return value of `takeN`
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    to `mapProp('name', __)` where we map over
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//    the list and pull out each one's `name`
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getHighScorers :: [Object] -&gt; [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getHighScorers</span> <span class="pl-o">=</span> <span class="pl-nx">xs</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">,</span> <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">,</span> <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)))</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// results object here...
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getHighScorers</span><span class="pl-p">(</span><span class="pl-nx">results</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; [ 'Eowin', 'Bilbo', 'Frodo' ]
</span></span></span></code></pre><p><em><a href="https://goo.gl/9XsTQx">Try this code in the ramda REPL.</a></em></p><p>This is starting to look good, but that <code>getHighScorers</code> function is looking a bit dense. Since we have a seeming pipeline of transformations that we‚Äôre applying to a list, wouldn‚Äôt it be great if we could simply list these transformations in a ‚Äúflat‚Äù way (instead of a ‚Äúnested‚Äù way like we do above) and then pass the data to this list of transformations?</p><h2 id="enter-compose">Enter <code>compose</code></h2><p>Let‚Äôs take our <code>getHighScorers</code> function and rewrite it using <a href="http://ramdajs.com/docs/#compose">ramda‚Äôs compose function</a>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-nx">compose</span> <span class="pl-nx">from</span> <span class="pl-s1">'ramda/src/compose'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// const getHighScorers = xs =&gt;
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   mapProp('name', takeN(3, descBy('score', xs)))
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getHighScorers :: [Object] -&gt; [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getHighScorers</span> <span class="pl-o">=</span> <span class="pl-nx">xs</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span> <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span> <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">))(</span><span class="pl-nx">xs</span><span class="pl-p">)</span></span></span></code></pre><p>Let‚Äôs first clarify what <code>compose</code> is doing:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">f</span><span class="pl-p">,</span> <span class="pl-nx">g</span><span class="pl-p">)(</span><span class="pl-nx">x</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-nx">f</span><span class="pl-p">(</span><span class="pl-nx">g</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">))</span></span></span></code></pre><p>Say it aloud: ‚Äúf after g.‚Äù With <code>compose</code>, the function furthest to the <em>right</em> is applied first with the value (<code>x</code>), and the return value of that function is passed to the next function to its <em>left</em>, and repeat this until all functions have been applied.</p><p>Cool ‚Äì but wait! How can <code>descBy</code>, <code>takeN</code> and <code>mapProp</code> only accept one argument at a time when they all accept two?! In order to make these a reality, we can make use of <a href="http://ramdajs.com/docs/#curry">ramda‚Äôs curry function</a> which we dove into in my <a href="/ramda-chops-function-currying.html%5D">previous post on function currying</a>.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-nx">compose</span> <span class="pl-nx">from</span> <span class="pl-s1">'ramda/src/compose'</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-nx">curry</span> <span class="pl-nx">from</span> <span class="pl-s1">'ramda/src/curry'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// descBy :: String -&gt; [a] -&gt; [a]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">descBy</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">((</span><span class="pl-nx">prop</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">[...</span><span class="pl-nx">xs</span><span class="pl-p">].</span><span class="pl-nx">sort</span><span class="pl-p">((</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">a</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">&lt;</span> <span class="pl-nx">b</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">?</span> <span class="pl-mi">1</span> <span class="pl-o">:</span> <span class="pl-p">(</span><span class="pl-nx">a</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">===</span> <span class="pl-nx">b</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">]</span> <span class="pl-o">?</span> <span class="pl-mi">0</span> <span class="pl-o">:</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// takeN :: Number -&gt; [a] -&gt; [a]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">takeN</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">((</span><span class="pl-nx">n</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">xs</span><span class="pl-p">.</span><span class="pl-nx">slice</span><span class="pl-p">(</span><span class="pl-mi">0</span><span class="pl-p">,</span> <span class="pl-nx">n</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// mapProp :: String -&gt; [a] -&gt; [b]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">mapProp</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">((</span><span class="pl-nx">prop</span><span class="pl-p">,</span> <span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">xs</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">[</span><span class="pl-nx">prop</span><span class="pl-p">])</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getHighScorers :: [Object] -&gt; [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getHighScorers</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span> <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span> <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">))</span></span></span></code></pre><p><em><a href="https://goo.gl/NxEFhi">Try this code in the ramda REPL.</a></em></p><p>You may also notice that we removed <code>xs =&gt;</code> from <code>getHighScorers</code> because when we use compose and pass the final argument in at the end, it in fact becomes redundant. Our composition sits and waits for either the data to be applied or for it to be used another way: more compositions! This leads us down a powerful path whereby we can now compose different functions together and combine them into a final composition.</p><h2 id="composing-a-composition">Composing a Composition</h2><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getTop3 :: [a] -&gt; [a]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getTop3</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span> <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">))</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// getHighScorers :: [Object] -&gt; [String]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">getHighScorers</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span> <span class="pl-nx">getTop3</span><span class="pl-p">)</span></span></span></code></pre><p><em><a href="https://goo.gl/jRoCWZ">Try this code in the ramda REPL.</a></em></p><p>This is where we truly begin to see the power of <code>compose</code>, for we are able to break our functions or function compositions out into tiny little pieces that we chain together like water pipes or guitar pedals.</p><figure><img alt="Guitar pedals lined up side-by-side" decoding="async" height="800" loading="lazy" src="./images/rcfc-guitar-pedals.webp" width="600" /><figcaption> _Guitar pedals by [Henrik Hjortsh√∏j](https://unsplash.com/@hfranke)_ </figcaption></figure><p>We are now empowered (nay ‚Äì encouraged!) to provide meaningful names in the context of what we‚Äôre trying to accomplish.</p><p>Composing compositions also allows us to use our type signatures to tell a story about what behavior is expected with each little part on our path to the ultimate goal.</p><h2 id="pipe-vs-compose"><code>pipe</code> vs <code>compose</code></h2><p>For various reasons that are usally a matter of opinion, many people prefer function application to flow from <em>left to right</em> instead of <em>right to left</em> (the latter being what you get with <code>compose</code>). So if you find yourself thinking the same thing, <a href="http://ramdajs.com/docs/#pipe">pipe</a> is for you:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//      &lt;-------------   &lt;------   &lt;-------------
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">compose</span><span class="pl-p">(</span><span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span> <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span> <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">))(</span><span class="pl-nx">xs</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// versus
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//   --------------&gt;  -------&gt;  --------------&gt;
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">pipe</span><span class="pl-p">(</span><span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">),</span> <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span> <span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">))(</span><span class="pl-nx">xs</span><span class="pl-p">)</span></span></span></code></pre><h2 id="composing-promises">Composing Promises</h2><p>There‚Äôs really nothing to it! Instead of <code>compose</code> or <code>pipe</code>, use <a href="http://ramdajs.com/docs/#composeP">composeP</a> or <a href="http://ramdajs.com/docs/#pipeP">pipeP</a>.</p><h2 id="debugging">Debugging</h2><p>Once you adopt this pattern, you may find it initially difficult to inspect your data at a given point in the pipeline; however, here‚Äôs a tip that will solve most of your problems:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">compose</span><span class="pl-p">(</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-p">(</span><span class="pl-nx">console</span><span class="pl-p">.</span><span class="pl-nx">log</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">),</span> <span class="pl-nx">x</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// or
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">logIt</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-p">(</span><span class="pl-nx">console</span><span class="pl-p">.</span><span class="pl-nx">log</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">),</span> <span class="pl-nx">x</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">compose</span><span class="pl-p">(</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">mapProp</span><span class="pl-p">(</span><span class="pl-s1">'name'</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">logIt</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">takeN</span><span class="pl-p">(</span><span class="pl-mi">3</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">descBy</span><span class="pl-p">(</span><span class="pl-s1">'score'</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span></span></span></code></pre><p>This logs whatever the value in the pipeline is at that time and returns that value to pass it on just as it would have.</p><hr /><p>Thanks for reading! Until next time, <br> Robert</p></section></main><footer><span aria-hidden="true" class="heart">‚ô•</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">‚ô•</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>