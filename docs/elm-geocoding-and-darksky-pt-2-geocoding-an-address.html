<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
    <meta name="description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address.">
    <meta name="author" content="Robert Pearce">
    <meta name="keywords" content="elm, elm tutorial, elmlang, elm geocoding, elm darksky, elm weather, elm functional programming">
    <meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU">

    <meta property="og:site_name" content="Robert Pearce | Freelance Software Developer">
    <meta property="og:title" content="Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address">
    <meta property="og:url" content="https://robertwpearce.com/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">
    <meta property="og:description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address.">
    <meta property="og:image" content="https://robertwpearce.com/images/rain-window.jpg">
    
      <meta property="og:type" content="article">
    

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:site" content="Robert Pearce | Freelance Software Developer">
    <meta property="twitter:title" content="Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address">
    <meta property="twitter:description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address.">
    <meta property="twitter:image" content="https://robertwpearce.com/images/rain-window.jpg">
    <meta property="twitter:creator" content="@RobertWPearce">

    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="canonical" href="https://robertwpearce.com/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">
    <link href="//fonts.googleapis.com/css?family=Lato:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/css/default.css" />
    
      <link rel="stylesheet" href="/css/article.css" />
    
  </head>
  <body>
    <main>
  <nav class="nav">
  <div class="layout--constrained">
    <a class="nav__link" href="/">Home</a>
    <a class="nav__link" href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a>
    <a class="nav__link" href="/atom.xml">atom</a>
    <a class="nav__link" href="/rss.xml">rss</a>
  </div>
</nav>

  <article class="article">
    <div class="article__bg" style="background-image: url('/images/rain-window.jpg')">
      <header class="article__bgHeader">
        <div class="layout--constrained">
          <div class="article__bgTitleWrap">
            <h1 class="article__bgTitle">
              <a href="/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</a>
            </h1>
            <div class="article__bgSubHeader">
              <small class="italic">2017-07-30</small>
              
                <small class="article__bgPhotoCred italic">
                  [ photo credit <a href="https://unsplash.com/@gabrielediwald">Gabriele Diwald</a> ]
                </small>
              
            </div>
          </div>
        </div>
      </header>
    </div>
    <section class="layout--constrained">
      <header class="article__header">
        <h1 class="article__title">
          <a href="/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</a>
        </h1>
        <small class="italic">2017-07-30</small>
      </header>
      <p>This is part 2 of a multipart series where we will be building a small weather forecast app using <a href="http://elm-lang.org/">Elm</a>, <a href="https://developers.google.com/maps/documentation/geocoding/start">Google’s Geocoding API</a> and the <a href="https://darksky.net/dev/">DarkSky API</a>. Instead of doing everything in one massive post, I’ve broken the steps down into parts of a series. Here is the series plan:</p>
<ul>
<li><a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Pt. 1 – Setup Elm &amp; Proxy Servers</a></li>
<li>Pt. 2 – Geocoding an Address</li>
<li><a href="/blog/elm-geocoding-and-darksky-pt-3-fetching-the-current-weather.html">Pt. 3 – Fetching the Current Weather</a></li>
<li><a href="/blog/elm-geocoding-and-darksky-pt-4-extracting-our-elm-code.html">Pt. 4 – Extracting Our Elm Code</a></li>
</ul>
<p>If you’d like to code along with this tutorial, check out <a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">part 1</a> first to get set up.</p>
<p><em>Note: to learn more about the Elm language and syntax, check out the <a href="https://www.elm-tutorial.org/en/">Elm Tutorial</a>, the <a href="https://egghead.io/courses/start-using-elm-to-build-web-applications">EggHead.io Elm course</a>, subscribe to <a href="https://www.dailydrip.com/topics/elm">DailyDrip’s Elm Topic</a>, <a href="http://courses.knowthen.com">James Moore’s Elm Courses</a> or check out <a href="http://exercism.io/languages/elm/about">Elm on exercism.io</a>.</em></p>
<h2 id="overview">Overview</h2>
<p>Before we can send a weather forecast request to DarkSky, we need to geocode an address to get its latitude and longitutde. In this post, we’re going to use Elm and our geocoding server from <a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Part 1</a> to geocode an address based on a user’s input in a text box.</p>
<p>Warning: this is a hefty post.</p>
<h2 id="project-source-code">Project Source Code</h2>
<p>The project we’re making will be broken into parts here (branches will be named for each part): <a href="https://github.com/rpearce/elm-geocoding-darksky/" class="uri">https://github.com/rpearce/elm-geocoding-darksky/</a>. Be sure to check out the other branches to see the other parts as they become available.</p>
<p>The code for this part is located in the <code>pt-2</code> branch: <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2" class="uri">https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2</a>.</p>
<h2 id="steps-for-today">Steps for Today</h2>
<p>What we want to do with our program today is create an HTTP GET request with an address that is input by a user and returns the latitude and longitude. These steps will get us there:</p>
<ol>
<li>Defining our primary data model</li>
<li>Understanding Google’s geocode response data</li>
<li>Modeling the geocode response data</li>
<li>Creating JSON decoders</li>
<li>Building our view and listening for events</li>
<li>Adding message types</li>
<li>Writing our update function</li>
<li>Making our request</li>
<li>Handling the geocode response</li>
<li>Final wiring up with the main function &amp; defaults</li>
</ol>
<h2 id="defining-our-primary-data-model">1: Defining our primary data model</h2>
<p>At the top level for our app, we only care about an address and latitude and longitude coordinates. While the address’ type will definitely be <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/String">String</a>, we can choose between a <a href="https://guide.elm-lang.org/core_language.html#records">record</a> or <a href="https://guide.elm-lang.org/core_language.html#tuples">tuple</a> to house our coordinates; however, each of these values must be a <code>Float</code> type, as coordinates come in decimal format. For no particular reason, we’re going to use a tuple.</p>
<pre class="elm"><code>type alias Model =
    { address : String
    , coords : Coords
    }


type alias Coords =
    ( Float, Float )</code></pre>
<p>I like to keep my models/type aliases fairly clean and primed for re-use in type definitions, so I created a separate type alias, <code>Coords</code>, to represent <code>( Float, Float )</code>.</p>
<h2 id="understanding-googles-geocode-response-data">2: Understanding Google’s geocode response data</h2>
<p>Let’s take a look at what a geocoding request’s response data for <code>Auckland</code> looks like so we can understand what we’re working with.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="st">&quot;results&quot;</span><span class="op">:</span> [</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="op">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">      <span class="st">&quot;geometry&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="st">&quot;location&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">          <span class="st">&quot;lat&quot;</span><span class="op">:</span> <span class="fl">-36.8484597</span><span class="op">,</span></a>
<a class="sourceLine" id="cb2-7" title="7">          <span class="st">&quot;lng&quot;</span><span class="op">:</span> <span class="fl">174.7633315</span></a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="op">},</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb2-10" title="10">      <span class="op">},</span></a>
<a class="sourceLine" id="cb2-11" title="11">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb2-12" title="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-13" title="13">  ]<span class="op">,</span></a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="st">&quot;status&quot;</span><span class="op">:</span> <span class="st">&quot;OK&quot;</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>If you’ve set up your <a href="/blog/node-js-geocoding-proxy-with-paperplane.html">geocoding proxy</a>, you can see these same results by running this command:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">λ <span class="ex">curl</span> localhost:5050/geocode/Auckland</a></code></pre></div>
<p>We can see here that we get back a <code>status</code> string and a <code>results</code> list where one of the results contains a <code>geometry</code> object, and inside of that, we find <code>location</code> and finally, our quarry: <code>lat</code> and <code>lng</code>. If we were searching for this with JavaScript, we might find this data like so:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="va">response</span>.<span class="va">results</span>.<span class="at">find</span>(x <span class="op">=&gt;</span> x[<span class="st">&#39;geometry&#39;</span>]).<span class="va">geometry</span>.<span class="at">location</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">// { lat: -36.8484597, lng: 174.7633315 }</span></a></code></pre></div>
<p>What would happen in vanilla JavaScript if there were no results, or those object keys didn’t exist? Elm steps up to help us solve for the unexpected.</p>
<h2 id="modeling-the-geocode-response-data">3: Modeling the geocode response data</h2>
<p>Based on the geocoding response, let’s list out what we’re looking at:</p>
<ul>
<li>a string, <code>status</code></li>
<li>a list of <code>results</code></li>
<li>each result has a <code>geometry</code> object</li>
<li>a <code>geometry</code> object has a <code>location</code> object</li>
<li>a <code>location</code> object has both <code>lat</code> and <code>lng</code> properties, each of which use decimal points</li>
</ul>
<p>Since we’re going to need decode these bits of data and reuse the types a few times, let’s create type aliases for each of these concepts (prefixed with <code>Geo</code>):</p>
<pre class="elm"><code>type alias GeoModel =
    { status : String
    , results : List GeoResult
    }


type alias GeoResult =
    { geometry : GeoGeometry }


type alias GeoGeometry =
    { location : GeoLocation }


type alias GeoLocation =
    { lat : Float
    , lng : Float
    }</code></pre>
<p>If you’re not sure what <code>type alias</code> means, read more about <a href="https://guide.elm-lang.org/types/type_aliases.html">type aliases in <em>An Introduction to Elm</em></a>.</p>
<h2 id="creating-json-decoders">4: Creating JSON decoders</h2>
<p>There are a number of ways to decode JSON in Elm, and <a href="https://www.brianthicks.com">Brian Hicks</a> has <a href="https://www.brianthicks.com/post/2016/08/22/decoding-large-json-objects-a-summary/">written about this</a> (and has a <a href="https://www.brianthicks.com/json-survival-kit/">short book on decoding JSON</a>), and so have many others, such as <a href="https://robots.thoughtbot.com/decoding-json-structures-with-elm">Thoughtbot</a>. Today, we’re going to be working with <a href="https://github.com/NoRedInk/elm-decode-pipeline">NoRedInk’s elm-decode-pipeline</a>.</p>
<p>First, we install the package into our project:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">λ <span class="ex">elm</span> package install NoRedInk/elm-decode-pipeline</a></code></pre></div>
<p>In our <code>Main.elm</code> file, we can import what we’ll need from Elm’s <a href="">core Json-Decode module</a> as well as the package we’ve just installed.</p>
<pre class="elm"><code>-- Importing from elm core.
-- We know from our type aliases that all we&#39;re working
-- with right now are floats, lists and strings.
import Json.Decode exposing (float, list, string, Decoder)

-- importing from elm-decode-pipeline
import Json.Decode.Pipeline exposing (decode, required)</code></pre>
<p>Now we can write our decoders!</p>
<pre class="elm"><code>decodeGeo : Decoder GeoModel
decodeGeo =
    decode GeoModel
        |&gt; required &quot;status&quot; string
        |&gt; required &quot;results&quot; (list decodeGeoResult)


decodeGeoResult : Decoder GeoResult
decodeGeoResult =
    decode GeoResult
        |&gt; required &quot;geometry&quot; decodeGeoGeometry


decodeGeoGeometry : Decoder GeoGeometry
decodeGeoGeometry =
    decode GeoGeometry
        |&gt; required &quot;location&quot; decodeGeoLocation


decodeGeoLocation : Decoder GeoLocation
decodeGeoLocation =
    decode GeoLocation
        |&gt; required &quot;lat&quot; float
        |&gt; required &quot;lng&quot; float</code></pre>
<p>Here we declare that we’d like to decode the JSON string according to our type aliases, such as <code>GeoModel</code>, and we expect certain keys to have certain value types. In the case of <code>status</code>, that’s just a string; however, with <code>results</code>, we actually have a list of some other type of data, <code>GeoResult</code>, and so we create another decoder function down the line until we dig deep enough to find what we’re looking for. In short, we’re opting for functions and type-checking over deep nesting.</p>
<p>Why does this feel so verbose? Personally, I’m not yet comfortable using <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#at">Json.Decode.at</a>, which might look like</p>
<pre class="elm"><code>decodeString (at [ &quot;results&quot; ] (list (at [ &quot;geometry&quot;, &quot;location&quot; ] (keyValuePairs float)))) jsonString</code></pre>
<p>But with the former approach, we get to be <em>very</em> specific with exactly what we are expecting our data to be shaped like while maintaining clarity.</p>
<h2 id="building-our-view-and-listening-for-events">5: Building our view and listening for events</h2>
<p>It’s time to add our <code>view</code> function. All we’re going for today is</p>
<ul>
<li>a text input that will keep track of the <code>address</code> by responding to the <code>onInput</code> event</li>
<li>a form around the input that listens for the <code>onSubmit</code> event</li>
<li>a paragraph to display the coordinates; for example, <code>Coords: (123, 456)</code></li>
</ul>
<p>As usual, let’s download <a href="https://github.com/elm-lang/html">the official elm-lang/html package</a>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1">λ <span class="ex">elm</span> package install elm-lang/html</a></code></pre></div>
<p>Then let’s import what we need from it:</p>
<pre class="elm"><code>import Html exposing (Html, div, form, input, p, text)
import Html.Attributes exposing (placeholder, type_, value)
import Html.Events exposing (onInput, onSubmit)</code></pre>
<p>Each import is a function that we can use to help generate HTML5 elements which Elm then works with behind the scenes.</p>
<pre class="elm"><code>view : Model -&gt; Html Msg
view model =
    div []
        [ form [ onSubmit SendAddress ]
            [ input
                [ type_ &quot;text&quot;
                , placeholder &quot;City&quot;
                , value model.address
                , onInput UpdateAddress
                ]
                []
            ]
        , p [] [ text (&quot;Coords: &quot; ++ (toString model.coords)) ]
        ]</code></pre>
<p>Our <code>view</code> function takes in our model and uses Elm functions to then render output. Great! But what are <code>SendAdress</code> and <code>UpdateAddress</code>? If you’re coming from JavaScript, you might think these are callbacks or higher-order functions, but they are not. They are custom message types (that we’ll define momentarily) that will be used in our <code>update</code> function to determine what flow our application should take next.</p>
<h2 id="adding-message-types">6: Adding message types</h2>
<p>Thus far, we know of two message types, <code>Update</code> and <code>SendAddress</code>, but how do we define them? If you look at our <code>view</code> function again, you’ll see the return type <code>Html Msg</code>. The second part of this will be the <code>type</code> that we create, and our custom message types will be a part of that! This is something called a <a href="https://guide.elm-lang.org/types/union_types.html">union type</a>.</p>
<pre class="elm"><code>type Msg
    = UpdateAddress String
    | SendAddress
    | NoOp</code></pre>
<p>We will be adding more to this shortly, but this is all we have come across thus far.</p>
<h2 id="writing-our-update-function">7: Writing our update function</h2>
<p>Staying consistent with <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, we’ll define our <code>update</code> function in order to update our data and fire off any commands that need happen. If you’re familiar with Redux, this is where the idea for a “reducer” came from.</p>
<p>This is tough to do in a blog post, so please be patient, and we’ll walk through this:</p>
<pre class="elm"><code>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateAddress text -&gt;
            ( { model | address = text }
            , Cmd.none
            )

        SendAddress -&gt;
            ( model, sendAddress model.address )

        -- more code here shortly...

        _ -&gt;
            ( model, Cmd.none )</code></pre>
<p>Let’s walk through this step-by-step:</p>
<ul>
<li>if the message type is <code>UpdateAddress</code>, then
<ol>
<li>we’re expecting a <code>string</code> (defined in our union type)</li>
<li>we’ll call the argument <code>text</code></li>
<li>we’ll then return a tuple of our updated model and a <code>Cmd</code> to essentially do nothing else (it’ll pass through the union type and settle on the <code>NoOp</code>)</li>
</ol></li>
<li>if the message type is <code>SendAddress</code>, then
<ol>
<li>we’ll accept <em>no</em> parameters</li>
<li>we’ll return a tuple of our model <em>with no changes</em> and a command that we haven’t defined yet. This is where we call the function that will actually go and get our geocode data!</li>
</ol></li>
</ul>
<h2 id="making-our-request">8: Making our request</h2>
<p>In order to build and send HTTP requests, we’ll need to make sure we download the <a href="https://github.com/elm-lang/http">elm-lang/http</a> package:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">λ <span class="ex">elm</span> package install elm-lang/http</a></code></pre></div>
<p>and import it:</p>
<pre class="elm"><code>import Http</code></pre>
<p>In our <code>update</code> function, we referenced a function named <code>sendAddress</code> and passed it our model’s address as a parameter. This function should accept a string, initiate our HTTP request and return a command with a message.</p>
<pre class="elm"><code>sendAddress : String -&gt; Cmd Msg
sendAddress address =
    Http.get (geocodingUrl address) decodeGeo
        |&gt; Http.send ReceiveGeocoding

geocodingUrl : String -&gt; String
geocodingUrl address =
    &quot;http://localhost:5050/geocode/&quot; ++ address</code></pre>
<p>Our <code>sendAddress</code> function does this:</p>
<ol>
<li>it builds a GET request using two arguments: a URL (derived from <code>geocodingUrl</code>) and our <code>decodeGeo</code> decoder function</li>
<li>it then pipes the return value from <code>Http.get</code> to be the second argument for <code>Http.send</code></li>
</ol>
<p>Note that <code>Http.send</code>’s first argument is a <code>Msg</code> that we haven’t defined yet, so let’s add that to our <code>Msg</code> union type:</p>
<pre class="elm"><code>type Msg
    = UpdateAddress String
    | SendAddress
    | ReceiveGeocoding (Result Http.Error GeoModel)
    | NoOp</code></pre>
<p>Basically, we’ll either get back an HTTP error or a data structure in the shape of our <code>GeoModel</code>.</p>
<h2 id="handling-the-geocode-response">9: Handling the geocode response</h2>
<p>Finally, we now need to handle the successful and erroneous responses in our update function:</p>
<pre class="elm"><code>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateAddress text -&gt;
            ( { model | address = text }
            , Cmd.none
            )

        SendAddress -&gt;
            ( model, sendAddress model.address )

        ReceiveGeocoding (Ok { results, status }) -&gt;
            let
                result =
                    case status of
                        &quot;OK&quot; -&gt;
                            results
                                |&gt; List.head
                                |&gt; Maybe.withDefault initialGeoResult

                        _ -&gt;
                            initialGeoResult

                location =
                    result.geometry.location

                newModel =
                    { model | coords = ( location.lat, location.lng ) }
            in
                ( newModel, Cmd.none )

        ReceiveGeocoding (Err _) -&gt;
            ( model, Cmd.none )

        _ -&gt;
            ( model, Cmd.none )


-- This should go with other `init`s
-- but is placed here for relevance
initialGeoResult : GeoResult
initialGeoResult =
    { geometry =
        { location =
            { lat = 0
            , lng = 0
            }
        }
    }</code></pre>
<p>Instead of having success/error logic inside one <code>ReceiveGeocoding</code> case match, we use Elm’s pattern matching to allow us to match on the message and <code>Ok</code> or <code>Err</code> <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Result">results</a>.</p>
<p>Again, let’s do this step-by-step:</p>
<ul>
<li><code>ReceiveGeocoding</code> is <code>OK</code>
<ol>
<li>we destructure the response into <code>results</code> and <code>status</code> variables</li>
<li>we check the value of <code>status</code> from the response to make sure all is well</li>
<li>if status is <code>&quot;OK&quot;</code>, we try to get the first item in the <code>results</code> list and fallback to <code>initialGeoResult</code> if there are no results (I love Elm for enforcing this)</li>
<li>if status is <em>not</em> <code>&quot;OK&quot;</code>, we fall back to the <code>initialGeoResult</code></li>
<li>we then access the <code>location</code> record, build an updated model record, and return it</li>
</ol></li>
<li><code>ReceiveGeocoding</code> is <code>Err</code>
<ol>
<li>we simply return the model</li>
</ol></li>
</ul>
<h2 id="final-wiring-up-with-the-main-function-defaults">10: Final wiring up with the main function &amp; defaults</h2>
<p>Now that we’re through the core of the application’s contents, we can wire up the remaining bits and get it to compile:</p>
<pre class="elm"><code>-- Define our HTML program
main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


-- Here is our initial model
init : ( Model, Cmd Msg )
init =
    ( initialModel, Cmd.none )


initialModel : Model
initialModel =
    { address = &quot;&quot;
    , coords = ( 0, 0 )
    }


-- We&#39;re not using any subscriptions,
-- so we&#39;ll define none
subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Sub.none</code></pre>
<p>Remember that you can look at the <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2">source code for this part</a> as a guide.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>This has been a massive post on simply fetching geocode data from an API. I’ve found it’s difficult to write posts on Elm in little bits, for you have to have everything in the right place and defined before it’ll work. Subsequent posts in this series will be shorter, as we’ll have already done the heavy-lifting.</p>
<p>Until next time, <br> Robert</p>
    </section>
  </article>
</main>

<section class="subscribe section--padded bg--gray">
  <div class="layout--constrained">
    <h2 class="subscribe__header">Get notified of new posts</h2>

    <form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="subscribe__form">
      <div id="mce-responses">
        <div class="response" id="mce-error-response" style="display:none"></div>
        <div class="response" id="mce-success-response" style="display:none"></div>
      </div>
      <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value=""></div>
      <div class="subscribe__section">
        <label for="mce-EMAIL" class="subscribe__label">Email Address</label>
        <input type="email" value="" id="mce-EMAIL" class="subscribe__input" name="EMAIL" placeholder="you@greatemail.com">
        <input type="submit" value="Subscribe" name="subscribe" class="subscribe__submit">
      </div>
      <small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small>
    </form>

    <p>
      <small>(or subscribe to the <a href="/atom.xml">atom</a> or <a href="/rss.xml">rss</a> feeds)</small>
    </p>
  </div>
</section>


  </body>
</html>
