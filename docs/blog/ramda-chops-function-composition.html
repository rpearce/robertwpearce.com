<!DOCTYPE html><html lang="en"><head><title>Ramda Chops: Function Composition</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta name="description" content="Learn about function composition with ramda's compose function."><meta property="og:site_name" content="Robert Pearce | Freelance Software Developer"><meta property="og:title" content="Ramda Chops: Function Composition"><meta property="og:url" content="https://robertwpearce.com/blog/ramda-chops-function-composition.html"><meta property="og:description" content="Learn about function composition with ramda's compose function."><meta property="og:image" content="/images/sheep-hill-building.jpg"><meta property="og:type" content="article"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="Robert Pearce | Freelance Software Developer"><meta property="twitter:title" content="Ramda Chops: Function Composition"><meta property="twitter:description" content="Learn about function composition with ramda's compose function."><meta property="twitter:image" content="/images/sheep-hill-building.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://robertwpearce.com/blog/ramda-chops-function-composition.html"><link rel="stylesheet" href="/styles.css"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><link href="//fonts.googleapis.com/css?family=Lato:400" rel="stylesheet" type="text/css"></head><body><main><nav><div class="layout--constrained"><ul class="nav--main list--bare list--horz"><li><a href="/">Home</a></li><li><a href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a></li></ul></div></nav><article class="article"><div class="article__background" style="background-image: url('/images/sheep-hill-building.jpg')"><header class="article__bgHeader"><div class="layout--constrained"><div class="article__bgTitleContainer"><h1 class="heading--trim"><a href="/blog/ramda-chops-function-composition.html">Ramda Chops: Function Composition</a></h1><div class="article__subHeader"><small>Jan 26, 2018</small> <small class="photoCred">[photo credit <a href="https://unsplash.com/@kotomanov">Alex Kotomanov</a>]</small></div></div></div></header></div><div class="layout--constrained"><header class="article__header heading--fatBottomBorder"><h1 class="heading--trim"><a href="/blog/ramda-chops-function-composition.html">Ramda Chops: Function Composition</a></h1><small>Jan 26, 2018</small></header><p><em>Thanks to <a href="https://twitter.com/evilsoft">@evilsoft</a> and <a href="https://twitter.com/zerkms">@zerkms</a> for their review of this post.</em></p><p><em>Composition</em> is defined as &quot;the combining of distinct parts or elements to form a whole.&quot; <sup><a href="https://www.wordnik.com/words/composition">source</a></sup> If we apply this thinking to functions in programming, then <em>function composition</em> can be seen as the combining of functions to form a new function that is <em>composed</em> of said functions. Now that that word salad is over, let&#39;s get to work.</p><p>We have a task, and our task is to write a function that</p><ol><li>accepts a list of objects containing <code>score</code> (<code>Number</code>) and <code>name</code> (<code>String</code>) properties</li><li>returns the top 3 scorers&#39; names from highest to lowest</li></ol><p>Here are the unordered results that we have to work with:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> results = [
  { <span class="hljs-attr">score</span>: <span class="hljs-number">40</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Aragorn'</span> },
  { <span class="hljs-attr">score</span>: <span class="hljs-number">99</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Bilbo'</span> },
  { <span class="hljs-attr">score</span>: <span class="hljs-number">63</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Celeborn'</span> },
  { <span class="hljs-attr">score</span>: <span class="hljs-number">77</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Denethor'</span> },
  { <span class="hljs-attr">score</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Eowin'</span> },
  { <span class="hljs-attr">score</span>: <span class="hljs-number">94</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Frodo'</span> }
]</code></pre><hr><p><em>Other ramda posts:</em></p><ul><li><a href="/blog/ramda-chops-function-currying.html">Ramda Chops: Function Currying</a></li><li><a href="/blog/ramda-chops-safely-accessing-properties.html">Ramda Chops: Safely Accessing Properties</a></li><li><a href="/blog/ramda-chops-map-filter-and-reduce.html">Ramda Chops: Map, Filter &amp; Reduce</a></li></ul><h2><a class="heading--link" name="first-approach" href="#first-approach"><span>First Approach</span></a></h2><pre><code class="hljs js"><span class="hljs-comment">// getHighScorers :: [Object] -&gt; [String]</span>
<span class="hljs-keyword">const</span> getHighScorers = <span class="hljs-function"><span class="hljs-params">xs</span> =&gt;</span>
  [...xs]
    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.score - a.score)
    .slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
    .map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.name)

getHighScorers(results) <span class="hljs-comment">// =&gt; [ 'Eowin', 'Bilbo', 'Frodo' ]</span></code></pre><p>As cautious JavaScript developers, we know to reach for our functions and methods that don&#39;t mutate the objects we&#39;re receiving. We use a <em>copy</em> of the original list and chain together operations that <code>sort</code>, <code>slice</code> and <code>map</code> the return values of each operation until we arrive at <code>[ &#39;Eowin&#39;, &#39;Bilbo&#39;, &#39;Frodo&#39; ]</code>. Many folks would stop here, write a few unit tests and be done with it. We, on the other hand, will take this to the next level.</p><h2><a class="heading--link" name="extracting-reusable-functions" href="#extracting-reusable-functions"><span>Extracting Reusable Functions</span></a></h2><p>Our <code>getHighScorers</code> function has some functionality that we may want to use elsewhere in the future. Let&#39;s break down what we might be able to extract:</p><ul><li>a <em>sort by some prop in descending order</em> function (from <code>sort</code>)</li><li>a <em>take n items</em> function (from <code>slice</code>)</li><li>a <em>map prop</em> function (from <code>map</code>)</li></ul><pre><code class="hljs js"><span class="hljs-comment">// Altered slightly to allows us to compare</span>
<span class="hljs-comment">// things like strings and numbers.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// descBy :: (String, [a]) -&gt; [a]</span>
<span class="hljs-keyword">const</span> descBy = <span class="hljs-function">(<span class="hljs-params">prop, xs</span>) =&gt;</span>
  [...xs].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
    a[prop] &lt; b[prop] ? <span class="hljs-number">1</span> : (a[prop] === b[prop] ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>)
  )

<span class="hljs-comment">// takeN :: (Number, [a]) -&gt; [a]</span>
<span class="hljs-keyword">const</span> takeN = <span class="hljs-function">(<span class="hljs-params">n, xs</span>) =&gt;</span>
  xs.slice(<span class="hljs-number">0</span>, n)

<span class="hljs-comment">// mapProp :: (String, [a]) -&gt; [b]</span>
<span class="hljs-keyword">const</span> mapProp = <span class="hljs-function">(<span class="hljs-params">prop, xs</span>) =&gt;</span>
  xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x[prop])

<span class="hljs-comment">// 1. pass `score` and `xs` to `descBy`</span>
<span class="hljs-comment">// 2. pass the return value of `descBy`</span>
<span class="hljs-comment">//    to `takeN(3, __)`</span>
<span class="hljs-comment">// 3. pass the return value of `takeN`</span>
<span class="hljs-comment">//    to `mapProp('name', __)` where we map over</span>
<span class="hljs-comment">//    the list and pull out each one's `name`</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// getHighScorers :: [Object] -&gt; [String]</span>
<span class="hljs-keyword">const</span> getHighScorers = <span class="hljs-function"><span class="hljs-params">xs</span> =&gt;</span>
  mapProp(<span class="hljs-string">'name'</span>, takeN(<span class="hljs-number">3</span>, descBy(<span class="hljs-string">'score'</span>, xs)))

<span class="hljs-comment">// results object here...</span>

getHighScorers(results) <span class="hljs-comment">// =&gt; [ 'Eowin', 'Bilbo', 'Frodo' ]</span></code></pre><p><em><a href="https://goo.gl/9XsTQx">Try this code in the ramda REPL.</a></em></p><p>This is starting to look good, but that <code>getHighScorers</code> function is looking a bit dense. Since we have a seeming pipeline of transformations that we&#39;re applying to a list, wouldn&#39;t it be great if we could simply list these transformations in a &quot;flat&quot; way (instead of a &quot;nested&quot; way like we do above) and then pass the data to this list of transformations?</p><h2><a class="heading--link" name="enter-code-compose-code-" href="#enter-code-compose-code-"><span>Enter <code>compose</code></span></a></h2><p>Let&#39;s take our <code>getHighScorers</code> function and rewrite it using <a href="http://ramdajs.com/docs/#compose">ramda&#39;s compose function</a>:</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> compose <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda/src/compose'</span>

<span class="hljs-comment">// const getHighScorers = xs =&gt;</span>
<span class="hljs-comment">//   mapProp('name', takeN(3, descBy('score', xs)))</span>

<span class="hljs-comment">// getHighScorers :: [Object] -&gt; [String]</span>
<span class="hljs-keyword">const</span> getHighScorers = <span class="hljs-function"><span class="hljs-params">xs</span> =&gt;</span>
  compose(mapProp(<span class="hljs-string">'name'</span>), takeN(<span class="hljs-number">3</span>), descBy(<span class="hljs-string">'score'</span>))(xs)</code></pre><p>Let&#39;s first clarify what <code>compose</code> is doing:</p><pre><code class="hljs js">compose(f, g)(x) === f(g(x))</code></pre><p>Say it aloud: &quot;f after g.&quot; With <code>compose</code>, the function furthest to the <em>right</em> is applied first with the value (<code>x</code>), and the return value of that function is passed to the next function to its <em>left</em>, and repeat this until all functions have been applied.</p><p>Cool – but wait! How can <code>descBy</code>, <code>takeN</code> and <code>mapProp</code> only accept one argument at a time when they all accept two?! In order to make these a reality, we can make use of <a href="http://ramdajs.com/docs/#curry">ramda&#39;s curry function</a> which we dove into in my <a href="/blog/ramda-chops-function-currying.html%5D">previous post on function currying</a>.</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> compose <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda/src/compose'</span>
<span class="hljs-keyword">import</span> curry <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda/src/curry'</span>

<span class="hljs-comment">// descBy :: String -&gt; [a] -&gt; [a]</span>
<span class="hljs-keyword">const</span> descBy = curry(<span class="hljs-function">(<span class="hljs-params">prop, xs</span>) =&gt;</span>
  [...xs].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
    a[prop] &lt; b[prop] ? <span class="hljs-number">1</span> : (a[prop] === b[prop] ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>)
  )
)

<span class="hljs-comment">// takeN :: Number -&gt; [a] -&gt; [a]</span>
<span class="hljs-keyword">const</span> takeN = curry(<span class="hljs-function">(<span class="hljs-params">n, xs</span>) =&gt;</span>
  xs.slice(<span class="hljs-number">0</span>, n)
)

<span class="hljs-comment">// mapProp :: String -&gt; [a] -&gt; [b]</span>
<span class="hljs-keyword">const</span> mapProp = curry(<span class="hljs-function">(<span class="hljs-params">prop, xs</span>) =&gt;</span>
  xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x[prop])
)

<span class="hljs-comment">// getHighScorers :: [Object] -&gt; [String]</span>
<span class="hljs-keyword">const</span> getHighScorers =
  compose(mapProp(<span class="hljs-string">'name'</span>), takeN(<span class="hljs-number">3</span>), descBy(<span class="hljs-string">'score'</span>))</code></pre><p><em><a href="https://goo.gl/NxEFhi">Try this code in the ramda REPL.</a></em></p><p>You may also notice that we removed <code>xs =&gt;</code> from <code>getHighScorers</code> because when we use compose and pass the final argument in at the end, it in fact becomes redundant. Our composition sits and waits for either the data to be applied or for it to be used another way: more compositions! This leads us down a powerful path whereby we can now compose different functions together and combine them into a final composition.</p><h2><a class="heading--link" name="composing-a-composition" href="#composing-a-composition"><span>Composing a Composition</span></a></h2><pre><code class="hljs js"><span class="hljs-comment">// getTop3 :: [a] -&gt; [a]</span>
<span class="hljs-keyword">const</span> getTop3 =
  compose(takeN(<span class="hljs-number">3</span>), descBy(<span class="hljs-string">'score'</span>))

<span class="hljs-comment">// getHighScorers :: [Object] -&gt; [String]</span>
<span class="hljs-keyword">const</span> getHighScorers =
  compose(mapProp(<span class="hljs-string">'name'</span>), getTop3)</code></pre><p><em><a href="https://goo.gl/jRoCWZ">Try this code in the ramda REPL.</a></em></p><p>This is where we truly begin to see the power of <code>compose</code>, for we are able to break our functions or function compositions out into tiny little pieces that we chain together like water pipes or guitar pedals.</p><figure><img src="/images/guitar-pedals.jpg" alt="guitar pedals"><figcaption>_Guitar pedals by [Henrik Hjortshøj](https://unsplash.com/@hfranke)_</figcaption></figure><p>We are now empowered (nay – encouraged!) to provide meaningful names in the context of what we&#39;re trying to accomplish.</p><p>Composing compositions also allows us to use our type signatures to tell a story about what behavior is expected with each little part on our path to the ultimate goal.</p><h2><a class="heading--link" name="-code-pipe-code-vs-code-compose-code-" href="#-code-pipe-code-vs-code-compose-code-"><span><code>pipe</code> vs <code>compose</code></span></a></h2><p>For various reasons that are usally a matter of opinion, many people prefer function application to flow from <em>left to right</em> instead of <em>right to left</em> (the latter being what you get with <code>compose</code>). So if you find yourself thinking the same thing, <a href="http://ramdajs.com/docs/#pipe">pipe</a> is for you:</p><pre><code class="hljs js"><span class="hljs-comment">//      &lt;-------------   &lt;------   &lt;-------------</span>
compose(mapProp(<span class="hljs-string">'name'</span>), takeN(<span class="hljs-number">3</span>), descBy(<span class="hljs-string">'score'</span>))(xs)

<span class="hljs-comment">// versus</span>

<span class="hljs-comment">//   --------------&gt;  -------&gt;  --------------&gt;</span>
pipe(descBy(<span class="hljs-string">'score'</span>), takeN(<span class="hljs-number">3</span>), mapProp(<span class="hljs-string">'name'</span>))(xs)</code></pre><h2><a class="heading--link" name="composing-promises" href="#composing-promises"><span>Composing Promises</span></a></h2><p>There&#39;s really nothing to it! Instead of <code>compose</code> or <code>pipe</code>, use <a href="http://ramdajs.com/docs/#composeP">composeP</a> or <a href="http://ramdajs.com/docs/#pipeP">pipeP</a>.</p><h2><a class="heading--link" name="debugging" href="#debugging"><span>Debugging</span></a></h2><p>Once you adopt this pattern, you may find it initially difficult to inspect your data at a given point in the pipeline; however, here&#39;s a tip that will solve most of your problems:</p><pre><code class="hljs js">compose(
  mapProp(<span class="hljs-string">'name'</span>),
  x =&gt; (<span class="hljs-built_in">console</span>.log(x), x),
  takeN(<span class="hljs-number">3</span>),
  descBy(<span class="hljs-string">'score'</span>)
)

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">const</span> logIt = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> (<span class="hljs-built_in">console</span>.log(x), x)

compose(
  mapProp(<span class="hljs-string">'name'</span>),
  logIt,
  takeN(<span class="hljs-number">3</span>),
  descBy(<span class="hljs-string">'score'</span>)
)</code></pre><p>This logs whatever the value in the pipeline is at that time and returns that value to pass it on just as it would have.</p><hr><p>Thanks for reading! Until next time,<br>Robert</p></div></article><section class="section--padded bg--gray"><div class="layout--constrained"><h2>Get notified of new posts</h2><!-- Begin MailChimp Signup Form --><form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="form"><div id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value=""></div><div class="form__container"><label for="mce-EMAIL" class="form__label">Email Address</label> <input type="email" value="" id="mce-EMAIL" class="form__input" name="EMAIL" placeholder="you@greatemail.com"> <input type="submit" value="Subscribe" name="subscribe" class="form__submit"></div><small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small></form><!--End mc_embed_signup--></div></section></main></body></html>