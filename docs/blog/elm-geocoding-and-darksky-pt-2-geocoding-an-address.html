<!DOCTYPE html><html lang="en"><head><title>Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta name="description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address."><meta property="og:site_name" content="Robert Pearce | Freelance Software Developer"><meta property="og:title" content="Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address"><meta property="og:url" content="https://robertwpearce.com/blog/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html"><meta property="og:description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address."><meta property="og:image" content="/images/rain-window.jpg"><meta property="og:type" content="article"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://robertwpearce.com/blog/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html"><link rel="stylesheet" href="/styles.css"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><link href="//fonts.googleapis.com/css?family=Lato:400" rel="stylesheet" type="text/css"></head><body><main><nav><div class="layout--constrained"><ul class="nav--main list--bare list--horz"><li><a href="/">Home</a></li><li><a href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a></li></ul></div></nav><article class="article"><div class="article__background" style="background-image: url('/images/rain-window.jpg')"><header class="article__bgHeader"><div class="layout--constrained"><div class="article__bgTitleContainer"><h1 class="heading--trim"><a href="/blog/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</a></h1><div class="article__subHeader"><small>July 30, 2017</small> <small class="photoCred">[photo credit <a href="https://unsplash.com/@gabrielediwald">Gabriele Diwald</a>]</small></div></div></div></header></div><div class="layout--constrained"><header class="article__header heading--fatBottomBorder"><h1 class="heading--trim"><a href="/blog/elm-geocoding-and-darksky-pt-2-geocoding-an-address.html">Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</a></h1><small>July 30, 2017</small></header><p>This is part 2 of a multipart series where we will be building a small weather forecast app using <a href="http://elm-lang.org/">Elm</a>, <a href="https://developers.google.com/maps/documentation/geocoding/start">Google&#39;s Geocoding API</a> and the <a href="https://darksky.net/dev/">DarkSky API</a>. Instead of doing everything in one massive post, I&#39;ve broken the steps down into parts of a series. Here is the series plan:</p><ul><li><a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Pt. 1 – Setup Elm &amp; Proxy Servers</a></li><li>Pt. 2 – Geocoding an Address</li><li><span class="faded">(wip) Pt. 3 – Fetching the Current Weather</span></li><li><span class="faded">(wip) Pt. 4 – Fetching the Weather Forecast</span></li><li><span class="faded">(wip) Pt. 5 – Extracting our Elm Code</span></li><li><span class="faded">(wip) Pt. 6 – Building for Semi-Production</span></li></ul><p>If you&#39;d like to code along with this tutorial, check out <a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">part 1</a> first to get set up.</p><p><em>Note: to learn more about the Elm language and syntax, check out the <a href="https://www.elm-tutorial.org/en/">Elm Tutorial</a>, the <a href="https://egghead.io/courses/start-using-elm-to-build-web-applications">EggHead.io Elm Course</a> or subscribe to <a href="https://www.dailydrip.com/topics/elm">DailyDrip&#39;s Elm Topic</a>.</em></p><h2><a class="heading--link" name="overview" href="#overview"><span>Overview</span></a></h2><p>Before we can send a weather forecast request to DarkSky, we need to geocode an address to get its latitude and longitutde. In this post, we&#39;re going to use Elm and our geocoding server from <a href="/blog/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Part 1</a> to geocode an address based on a user&#39;s input in a text box.</p><p>Warning: this is a hefty post.</p><h2><a class="heading--link" name="project-source-code" href="#project-source-code"><span>Project Source Code</span></a></h2><p>The project we&#39;re making will be broken into parts here (branches will be named for each part): <a href="https://github.com/rpearce/elm-geocoding-darksky/">https://github.com/rpearce/elm-geocoding-darksky/</a>. Be sure to check out the other branches to see the other parts as they become available.</p><p>The code for this part is located in the <code>pt-2</code> branch: <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2">https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2</a>.</p><h2><a class="heading--link" name="steps-for-today" href="#steps-for-today"><span>Steps for Today</span></a></h2><p>What we want to do with our program today is create an HTTP GET request with an address that is input by a user and returns the latitude and longitude. These steps will get us there:</p><ol><li>Defining our primary data model</li><li>Understanding Google&#39;s geocode response data</li><li>Modeling the geocode response data</li><li>Creating JSON decoders</li><li>Building our view and listening for events</li><li>Adding message types</li><li>Writing our update function</li><li>Making our request</li><li>Handling the geocode response</li><li>Final wiring up with the main function &amp; defaults</li></ol><h2><a class="heading--link" name="1-defining-our-primary-data-model" href="#1-defining-our-primary-data-model"><span>1: Defining our primary data model</span></a></h2><p>At the top level for our app, we only care about an address and latitude and longitude coordinates. While the address&#39; type will definitely be <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/String">String</a>, we can choose between a <a href="https://guide.elm-lang.org/core_language.html#records">record</a> or <a href="https://guide.elm-lang.org/core_language.html#tuples">tuple</a> to house our coordinates; however, each of these values must be a <code>Float</code> type, as coordinates come in decimal format. For no particular reason, we&#39;re going to use a tuple.</p><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Model</span> =
    { address : <span class="hljs-type">String</span>
    , coords : <span class="hljs-type">Coords</span>
    }


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Coords</span> =
    ( <span class="hljs-type">Float</span>, <span class="hljs-type">Float</span> )
</code></pre><p>I like to keep my models/type aliases fairly clean and primed for re-use in type definitions, so I created a separate type alias, <code>Coords</code>, to represent <code>( Float, Float )</code>.</p><h2><a class="heading--link" name="2-understanding-google-39-s-geocode-response-data" href="#2-understanding-google-39-s-geocode-response-data"><span>2: Understanding Google&#39;s geocode response data</span></a></h2><p>Let&#39;s take a look at what a geocoding request&#39;s response data for <code>Auckland</code> looks like so we can understand what we&#39;re working with.</p><pre><code class="hljs js">{
  <span class="hljs-string">"results"</span>: [
    {
      <span class="hljs-string">"geometry"</span>: {
        <span class="hljs-string">"location"</span>: {
          <span class="hljs-string">"lat"</span>: <span class="hljs-number">-36.8484597</span>,
          <span class="hljs-string">"lng"</span>: <span class="hljs-number">174.7633315</span>
        },
        <span class="hljs-comment">// ...</span>
      },
      <span class="hljs-comment">// ...</span>
    }
  ],
  <span class="hljs-string">"status"</span>: <span class="hljs-string">"OK"</span>
}
</code></pre><p>If you&#39;ve set up your <a href="/blog/node-js-geocoding-proxy-with-paperplane.html">geocoding proxy</a>, you can see these same results by running this command:</p><pre><code class="hljs bash">λ curl localhost:5050/geocode/Auckland
</code></pre><p>We can see here that we get back a <code>status</code> string and a <code>results</code> list where one of the results contains a <code>geometry</code> object, and inside of that, we find <code>location</code> and finally, our quarry: <code>lat</code> and <code>lng</code>. If we were searching for this with JavaScript, we might find this data like so:</p><pre><code class="hljs js">response.results.find(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x[<span class="hljs-string">'geometry'</span>]).geometry.location
<span class="hljs-comment">// { lat: -36.8484597, lng: 174.7633315 }</span>
</code></pre><p>What would happen in vanilla JavaScript if there were no results, or those object keys didn&#39;t exist? Elm steps up to help us solve for the unexpected.</p><h2><a class="heading--link" name="3-modeling-the-geocode-response-data" href="#3-modeling-the-geocode-response-data"><span>3: Modeling the geocode response data</span></a></h2><p>Based on the geocoding response, let&#39;s list out what we&#39;re looking at:</p><ul><li>a string, <code>status</code></li><li>a list of <code>results</code></li><li>each result has a <code>geometry</code> object</li><li>a <code>geometry</code> object has a <code>location</code> object</li><li>a <code>location</code> object has both <code>lat</code> and <code>lng</code> properties, each of which use decimal points</li></ul><p>Since we&#39;re going to need decode these bits of data and reuse the types a few times, let&#39;s create type aliases for each of these concepts (prefixed with <code>Geo</code>):</p><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">GeoModel</span> =
    { status : <span class="hljs-type">String</span>
    , results : <span class="hljs-type">List</span> <span class="hljs-type">GeoResult</span>
    }


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">GeoResult</span> =
    { geometry : <span class="hljs-type">GeoGeometry</span> }


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">GeoGeometry</span> =
    { location : <span class="hljs-type">GeoLocation</span> }


<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">GeoLocation</span> =
    { lat : <span class="hljs-type">Float</span>
    , lng : <span class="hljs-type">Float</span>
    }
</code></pre><p>If you&#39;re not sure what <code>type alias</code> means, read more about <a href="https://guide.elm-lang.org/types/type_aliases.html">type aliases in <em>An Introduction to Elm</em></a>.</p><h2><a class="heading--link" name="4-creating-json-decoders" href="#4-creating-json-decoders"><span>4: Creating JSON decoders</span></a></h2><p>There are a number of ways to decode JSON in Elm, and <a href="https://www.brianthicks.com">Brian Hicks</a> has <a href="https://www.brianthicks.com/post/2016/08/22/decoding-large-json-objects-a-summary/">written about this</a> (and has a <a href="https://www.brianthicks.com/json-survival-kit/">short book on decoding JSON</a>), and so have many others, such as <a href="https://robots.thoughtbot.com/decoding-json-structures-with-elm">Thoughtbot</a>. Today, we&#39;re going to be working with <a href="https://github.com/NoRedInk/elm-decode-pipeline">NoRedInk&#39;s elm-decode-pipeline</a>.</p><p>First, we install the package into our project:</p><pre><code class="hljs bash">λ elm package install NoRedInk/elm-decode-pipeline
</code></pre><p>In our <code>Main.elm</code> file, we can import what we&#39;ll need from Elm&#39;s <a href="">core Json-Decode module</a> as well as the package we&#39;ve just installed.</p><pre><code class="hljs elm"><span class="hljs-comment">-- Importing from elm core.</span>
<span class="hljs-comment">-- We know from our type aliases that all we're working</span>
<span class="hljs-comment">-- with right now are floats, lists and strings.</span>
<span class="hljs-keyword">import</span> Json.Decode <span class="hljs-keyword">exposing</span> (float, list, string, <span class="hljs-type">Decoder</span>)

<span class="hljs-comment">-- importing from elm-decode-pipeline</span>
<span class="hljs-keyword">import</span> Json.Decode.Pipeline <span class="hljs-keyword">exposing</span> (decode, required)
</code></pre><p>Now we can write our decoders!</p><pre><code class="hljs elm"><span class="hljs-title">decodeGeo</span> : <span class="hljs-type">Decoder</span> <span class="hljs-type">GeoModel</span>
<span class="hljs-title">decodeGeo</span> =
    decode <span class="hljs-type">GeoModel</span>
        |&gt; required <span class="hljs-string">"status"</span> string
        |&gt; required <span class="hljs-string">"results"</span> (list decodeGeoResult)


<span class="hljs-title">decodeGeoResult</span> : <span class="hljs-type">Decoder</span> <span class="hljs-type">GeoResult</span>
<span class="hljs-title">decodeGeoResult</span> =
    decode <span class="hljs-type">GeoResult</span>
        |&gt; required <span class="hljs-string">"geometry"</span> decodeGeoGeometry


<span class="hljs-title">decodeGeoGeometry</span> : <span class="hljs-type">Decoder</span> <span class="hljs-type">GeoGeometry</span>
<span class="hljs-title">decodeGeoGeometry</span> =
    decode <span class="hljs-type">GeoGeometry</span>
        |&gt; required <span class="hljs-string">"location"</span> decodeGeoLocation


<span class="hljs-title">decodeGeoLocation</span> : <span class="hljs-type">Decoder</span> <span class="hljs-type">GeoLocation</span>
<span class="hljs-title">decodeGeoLocation</span> =
    decode <span class="hljs-type">GeoLocation</span>
        |&gt; required <span class="hljs-string">"lat"</span> float
        |&gt; required <span class="hljs-string">"lng"</span> float
</code></pre><p>Here we declare that we&#39;d like to decode the JSON string according to our type aliases, such as <code>GeoModel</code>, and we expect certain keys to have certain value types. In the case of <code>status</code>, that&#39;s just a string; however, with <code>results</code>, we actually have a list of some other type of data, <code>GeoResult</code>, and so we create another decoder function down the line until we dig deep enough to find what we&#39;re looking for. In short, we&#39;re opting for functions and type-checking over deep nesting.</p><p>Why does this feel so verbose? Personally, I&#39;m not yet comfortable using <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#at">Json.Decode.at</a>, which might look like</p><pre><code class="hljs elm"><span class="hljs-title">decodeString</span> (at [ <span class="hljs-string">"results"</span> ] (list (at [ <span class="hljs-string">"geometry"</span>, <span class="hljs-string">"location"</span> ] (keyValuePairs float)))) jsonString
</code></pre><p>But with the former approach, we get to be <em>very</em> specific with exactly what we are expecting our data to be shaped like while maintaining clarity.</p><h2><a class="heading--link" name="5-building-our-view-and-listening-for-events" href="#5-building-our-view-and-listening-for-events"><span>5: Building our view and listening for events</span></a></h2><p>It&#39;s time to add our <code>view</code> function. All we&#39;re going for today is</p><ul><li>a text input that will keep track of the <code>address</code> by responding to the <code>onInput</code> event</li><li>a form around the input that listens for the <code>onSubmit</code> event</li><li>a paragraph to display the coordinates; for example, <code>Coords: (123, 456)</code></li></ul><p>As usual, let&#39;s download <a href="https://github.com/elm-lang/html">the official elm-lang/html package</a>:</p><pre><code class="hljs bash">λ elm package install elm-lang/html
</code></pre><p>Then let&#39;s import what we need from it:</p><pre><code class="hljs elm"><span class="hljs-keyword">import</span> Html <span class="hljs-keyword">exposing</span> (<span class="hljs-type">Html</span>, div, form, input, p, text)
<span class="hljs-keyword">import</span> Html.Attributes <span class="hljs-keyword">exposing</span> (placeholder, type_, value)
<span class="hljs-keyword">import</span> Html.Events <span class="hljs-keyword">exposing</span> (onInput, onSubmit)
</code></pre><p>Each import is a function that we can use to help generate HTML5 elements which Elm then works with behind the scenes.</p><pre><code class="hljs elm"><span class="hljs-title">view</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Html</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">view</span> model =
    div []
        [ form [ onSubmit <span class="hljs-type">SendAddress</span> ]
            [ input
                [ type_ "text"
                , placeholder <span class="hljs-string">"City"</span>
                , value model.address
                , onInput <span class="hljs-type">UpdateAddress</span>
                ]
                []
            ]
        , p [] [ text (<span class="hljs-string">"Coords: "</span> ++ (toString model.coords)) ]
        ]
</code></pre><p>Our <code>view</code> function takes in our model and uses Elm functions to then render output. Great! But what are <code>SendAdress</code> and <code>UpdateAddress</code>? If you&#39;re coming from JavaScript, you might think these are callbacks or higher-order functions, but they are not. They are custom message types (that we&#39;ll define momentarily) that will be used in our <code>update</code> function to determine what flow our application should take next.</p><h2><a class="heading--link" name="6-adding-message-types" href="#6-adding-message-types"><span>6: Adding message types</span></a></h2><p>Thus far, we know of two message types, <code>Update</code> and <code>SendAddress</code>, but how do we define them? If you look at our <code>view</code> function again, you&#39;ll see the return type <code>Html Msg</code>. The second part of this will be the <code>type</code> that we create, and our custom message types will be a part of that! This is something called a <a href="https://guide.elm-lang.org/types/union_types.html">union type</a>.</p><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>
    = <span class="hljs-type">UpdateAddress</span> <span class="hljs-type">String</span>
    | <span class="hljs-type">SendAddress</span>
    | <span class="hljs-type">NoOp</span>
</code></pre><p>We will be adding more to this shortly, but this is all we have come across thus far.</p><h2><a class="heading--link" name="7-writing-our-update-function" href="#7-writing-our-update-function"><span>7: Writing our update function</span></a></h2><p>Staying consistent with <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, we&#39;ll define our <code>update</code> function in order to update our data and fire off any commands that need happen. If you&#39;re familiar with Redux, this is where the idea for a &quot;reducer&quot; came from.</p><p>This is tough to do in a blog post, so please be patient, and we&#39;ll walk through this:</p><pre><code class="hljs elm"><span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; ( <span class="hljs-type">Model</span>, <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span> )
<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">UpdateAddress</span> text -&gt;
            ( { model | address = text }
            , <span class="hljs-type">Cmd</span>.none
            )

        <span class="hljs-type">SendAddress</span> -&gt;
            ( model, sendAddress model.address )

        <span class="hljs-comment">-- more code here shortly...</span>

        _ -&gt;
            ( model, <span class="hljs-type">Cmd</span>.none )
</code></pre><p>Let&#39;s walk through this step-by-step:</p><ul><li>if the message type is <code>UpdateAddress</code>, then<ol><li>we&#39;re expecting a <code>string</code> (defined in our union type)</li><li>we&#39;ll call the argument <code>text</code></li><li>we&#39;ll then return a tuple of our updated model and a <code>Cmd</code> to essentially do nothing else (it&#39;ll pass through the union type and settle on the <code>NoOp</code>)</li></ol></li><li>if the message type is <code>SendAddress</code>, then<ol><li>we&#39;ll accept <em>no</em> parameters</li><li>we&#39;ll return a tuple of our model <em>with no changes</em> and a command that we haven&#39;t defined yet. This is where we call the function that will actually go and get our geocode data!</li></ol></li></ul><h2><a class="heading--link" name="8-making-our-request" href="#8-making-our-request"><span>8: Making our request</span></a></h2><p>In order to build and send HTTP requests, we&#39;ll need to make sure we download the <a href="https://github.com/elm-lang/http">elm-lang/http</a> package:</p><pre><code class="hljs bash">λ elm package install elm-lang/http
</code></pre><p>and import it:</p><pre><code class="hljs elm"><span class="hljs-keyword">import</span> Http
</code></pre><p>In our <code>update</code> function, we referenced a function named <code>sendAddress</code> and passed it our model&#39;s address as a parameter. This function should accept a string, initiate our HTTP request and return a command with a message.</p><pre><code class="hljs elm"><span class="hljs-title">sendAddress</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">sendAddress</span> address =
    <span class="hljs-type">Http</span>.get (geocodingUrl address) decodeGeo
        |&gt; <span class="hljs-type">Http</span>.send <span class="hljs-type">ReceiveGeocoding</span>

<span class="hljs-title">geocodingUrl</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">geocodingUrl</span> address =
    <span class="hljs-string">"http://localhost:5050/geocode/"</span> ++ address
</code></pre><p>Our <code>sendAddress</code> function does this:</p><ol><li>it builds a GET request using two arguments: a URL (derived from <code>geocodingUrl</code>) and our <code>decodeGeo</code> decoder function</li><li>it then pipes the return value from <code>Http.get</code> to be the second argument for <code>Http.send</code></li></ol><p>Note that <code>Http.send</code>&#39;s first argument is a <code>Msg</code> that we haven&#39;t defined yet, so let&#39;s add that to our <code>Msg</code> union type:</p><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>
    = <span class="hljs-type">UpdateAddress</span> <span class="hljs-type">String</span>
    | <span class="hljs-type">SendAddress</span>
    | <span class="hljs-type">ReceiveGeocoding</span> (<span class="hljs-type">Result</span> <span class="hljs-type">Http</span>.<span class="hljs-type">Error</span> <span class="hljs-type">GeoModel</span>)
    | <span class="hljs-type">NoOp</span>
</code></pre><p>Basically, we&#39;ll either get back an HTTP error or a data structure in the shape of our <code>GeoModel</code>.</p><h2><a class="heading--link" name="9-handling-the-geocode-response" href="#9-handling-the-geocode-response"><span>9: Handling the geocode response</span></a></h2><p>Finally, we now need to handle the successful and erroneous responses in our update function:</p><pre><code class="hljs elm"><span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; ( <span class="hljs-type">Model</span>, <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span> )
<span class="hljs-title">update</span> msg model =
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">UpdateAddress</span> text -&gt;
            ( { model | address = text }
            , <span class="hljs-type">Cmd</span>.none
            )

        <span class="hljs-type">SendAddress</span> -&gt;
            ( model, sendAddress model.address )

        <span class="hljs-type">ReceiveGeocoding</span> (<span class="hljs-type">Ok</span> { results, status }) -&gt;
            <span class="hljs-keyword">let</span>
                result =
                    <span class="hljs-keyword">case</span> status <span class="hljs-keyword">of</span>
                        <span class="hljs-string">"OK"</span> -&gt;
                            results
                                |&gt; <span class="hljs-type">List</span>.head
                                |&gt; <span class="hljs-type">Maybe</span>.withDefault initialGeoResult

                        _ -&gt;
                            initialGeoResult

                location =
                    result.geometry.location

                newModel =
                    { model | coords = ( location.lat, location.lng ) }
            <span class="hljs-keyword">in</span>
                ( newModel, <span class="hljs-type">Cmd</span>.none )

        <span class="hljs-type">ReceiveGeocoding</span> (<span class="hljs-type">Err</span> _) -&gt;
            ( model, <span class="hljs-type">Cmd</span>.none )

        _ -&gt;
            ( model, <span class="hljs-type">Cmd</span>.none )


<span class="hljs-comment">-- This should go with other `init`s</span>
<span class="hljs-comment">-- but is placed here for relevance</span>
<span class="hljs-title">initialGeoResult</span> : <span class="hljs-type">GeoResult</span>
<span class="hljs-title">initialGeoResult</span> =
    { geometry =
        { location =
            { lat = <span class="hljs-number">0</span>
            , lng = <span class="hljs-number">0</span>
            }
        }
    }
</code></pre><p>Instead of having success/error logic inside one <code>ReceiveGeocoding</code> case match, we use Elm&#39;s pattern matching to allow us to match on the message and <code>Ok</code> or <code>Err</code> <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Result">results</a>.</p><p>Again, let&#39;s do this step-by-step:</p><ul><li><code>ReceiveGeocoding</code> is <code>OK</code><ol><li>we destructure the response into <code>results</code> and <code>status</code> variables</li><li>we check the value of <code>status</code> from the response to make sure all is well</li><li>if status is <code>&quot;OK&quot;</code>, we try to get the first item in the <code>results</code> list and fallback to <code>initialGeoResult</code> if there are no results (I love Elm for enforcing this)</li><li>if status is <em>not</em> <code>&quot;OK&quot;</code>, we fall back to the <code>initialGeoResult</code></li><li>we then access the <code>location</code> record, build an updated model record, and return it</li></ol></li><li><code>ReceiveGeocoding</code> is <code>Err</code><ol><li>we simply return the model</li></ol></li></ul><h2><a class="heading--link" name="10-final-wiring-up-with-the-main-function-amp-defaults" href="#10-final-wiring-up-with-the-main-function-amp-defaults"><span>10: Final wiring up with the main function &amp; defaults</span></a></h2><p>Now that we&#39;re through the core of the application&#39;s contents, we can wire up the remaining bits and get it to compile:</p><pre><code class="hljs elm"><span class="hljs-comment">-- Define our HTML program</span>
<span class="hljs-title">main</span> : <span class="hljs-type">Program</span> <span class="hljs-type">Never</span> <span class="hljs-type">Model</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">main</span> =
    <span class="hljs-type">Html</span>.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


<span class="hljs-comment">-- Here is our initial model</span>
<span class="hljs-title">init</span> : ( <span class="hljs-type">Model</span>, <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span> )
<span class="hljs-title">init</span> =
    ( initialModel, <span class="hljs-type">Cmd</span>.none )


<span class="hljs-title">initialModel</span> : <span class="hljs-type">Model</span>
<span class="hljs-title">initialModel</span> =
    { address = <span class="hljs-string">""</span>
    , coords = ( <span class="hljs-number">0</span>, <span class="hljs-number">0</span> )
    }


<span class="hljs-comment">-- We're not using any subscriptions,</span>
<span class="hljs-comment">-- so we'll define none</span>
<span class="hljs-title">subscriptions</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Sub</span> <span class="hljs-type">Msg</span>
<span class="hljs-title">subscriptions</span> model =
    <span class="hljs-type">Sub</span>.none
</code></pre><p>Remember that you can look at the <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2">source code for this part</a> as a guide.</p><h2><a class="heading--link" name="wrapping-up" href="#wrapping-up"><span>Wrapping Up</span></a></h2><p>This has been a massive post on simply fetching geocode data from an API. I&#39;ve found it&#39;s difficult to write posts on Elm in little bits, for you have to have everything in the right place and defined before it&#39;ll work. Subsequent posts in this series will be shorter, as we&#39;ll have already done the heavy-lifting.</p><p>Until next time,<br>Robert</p></div></article><section class="section--padded bg--gray"><div class="layout--constrained"><h2>Get Updates</h2><!-- Begin MailChimp Signup Form --><form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="form"><div id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px" aria-hidden="true"><input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value=""></div><div class="form__container"><label for="mce-EMAIL" class="form__label">Email Address</label><input type="email" value="" id="mce-EMAIL" class="form__input" name="EMAIL" placeholder="you@greatemail.com"> <input type="submit" value="Subscribe" name="subscribe" class="form__submit"></div><small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small></form><!--End mc_embed_signup--></div></section></main></body></html>