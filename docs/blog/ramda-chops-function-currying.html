<!DOCTYPE html><html lang="en"><head><title>Ramda Chops: Function Currying</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta name="description" content="How function currying works under the hood."><meta property="og:site_name" content="Robert Pearce | Freelance Software Developer"><meta property="og:title" content="Ramda Chops: Function Currying"><meta property="og:url" content="https://robertwpearce.com/blog/ramda-chops-function-currying.html"><meta property="og:description" content="How function currying works under the hood."><meta property="og:image" content="/images/shepherd-flock.jpg"><meta property="og:type" content="article"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="Robert Pearce | Freelance Software Developer"><meta property="twitter:title" content="Ramda Chops: Function Currying"><meta property="twitter:description" content="How function currying works under the hood."><meta property="twitter:image" content="/images/shepherd-flock.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://robertwpearce.com/blog/ramda-chops-function-currying.html"><link rel="stylesheet" href="/styles.css"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><link href="//fonts.googleapis.com/css?family=Lato:400" rel="stylesheet" type="text/css"></head><body><main><nav><div class="layout--constrained"><ul class="nav--main list--bare list--horz"><li><a href="/">Home</a></li><li><a href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a></li></ul></div></nav><article class="article"><div class="article__background" style="background-image: url('/images/shepherd-flock.jpg')"><header class="article__bgHeader"><div class="layout--constrained"><div class="article__bgTitleContainer"><h1 class="heading--trim"><a href="/blog/ramda-chops-function-currying.html">Ramda Chops: Function Currying</a></h1><div class="article__subHeader"><small>Jan 23, 2018</small> <small class="photoCred">[photo credit <a href="https://unsplash.com/@biegunwschodni">Biegun Wschodni</a>]</small></div></div></div></header></div><div class="layout--constrained"><header class="article__header heading--fatBottomBorder"><h1 class="heading--trim"><a href="/blog/ramda-chops-function-currying.html">Ramda Chops: Function Currying</a></h1><small>Jan 23, 2018</small></header><p><em>Thanks to <a href="https://github.com/jsilve">Jillian Silver</a> and <a href="https://twitter.com/evilsoft">@evilsoft</a> for their review of this post.</em></p><p>Functional Programming concepts have been pouring into the JavaScript community for a number of years now, and many of us struggle to keep up. I&#39;ve been lucky enough to be able to work with some mentors and functional tools that have helped me along the way. One of these tools is <a href="http://ramdajs.com">ramda.js</a>, and it was my gateway to the larger Functional Programming world. I hope it will be for you, as well.</p><p>To understand ramda, you first have to understand a concept known as &quot;currying.&quot; The ramda website states,</p><blockquote><p>The parameters to Ramda functions are arranged to make it convenient for currying.</p></blockquote><p>There are some function currying articles on the ramda site, such as <a href="http://fr.umio.us/favoring-curry/">Favoring Curry</a> and <a href="https://hughfdjackson.com/javascript/why-curry-helps/">Why Curry Helps</a> by Scott Sauyet, which are great for explaining the benefits and power of currying. Those articles (and many other resources) do great jobs of explaining how to use currying and why, so I&#39;ll briefly touch on those points, but I really want to focus on how it works under the hood and how this funny little concept will completely change the way that you program.</p><hr><p><em>Other ramda posts:</em></p><ul><li><a href="/blog/ramda-chops-function-composition.html">Ramda Chops: Function Composition</a></li><li><a href="/blog/ramda-chops-safely-accessing-properties.html">Ramda Chops: Safely Accessing Properties</a></li><li><a href="/blog/ramda-chops-map-filter-and-reduce.html">Ramda Chops: Map, Filter &amp; Reduce</a></li></ul><h2><a class="heading--link" name="rudimentary-currying" href="#rudimentary-currying"><span>Rudimentary Currying</span></a></h2><p>Many articles already cover this, so I&#39;ll keep it short.</p><p>Let&#39;s start with a function that takes two numbers and adds them together:</p><pre><code class="hljs js"><span class="hljs-comment">// add :: (Number, Number) -&gt; Number</span>
<span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
  a + b</code></pre><p>As our fake type signature describes, <code>add</code> takes two arguments (essentially, a <a href="https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples#Tuples%3CPaste%3E">tuple</a>) that are both of type <code>Number</code> and returns a value of type <code>Number</code>.</p><p>But if we wanted to create a function that adds <code>10</code> to anything, we could write the following:</p><pre><code class="hljs js"><span class="hljs-comment">// add :: Number -&gt; Number -&gt; Number</span>
<span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> b =&gt;
  a + b

<span class="hljs-comment">// which is the same as</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{
    <span class="hljs-keyword">return</span> a + b
  }
}

<span class="hljs-comment">// and then</span>

<span class="hljs-comment">// add10 :: Number -&gt; Number</span>
<span class="hljs-keyword">const</span> add10 = add(<span class="hljs-number">10</span>)

add10 <span class="hljs-comment">// =&gt; Function</span>
add10(<span class="hljs-number">4</span>) <span class="hljs-comment">// =&gt; 14</span></code></pre><p>Note the change in type signature: we now have singular arguments that are accepted at a time instead of the tuple style. When we provide the first argument, we are then returned a function that will sit and wait until all the functions are applied before giving us a value. This method can be useful in many situations, but consider the following:</p><pre><code class="hljs js">add(<span class="hljs-number">10</span>)(<span class="hljs-number">4</span>)</code></pre><p>That feels awkward, right? Fear not! There is a way.</p><h2><a class="heading--link" name="the-code-curry-code-function" href="#the-code-curry-code-function"><span>The <code>curry</code> Function</span></a></h2><p>Ramda provides us a function named <code>curry</code> that will take what might be considered a &quot;normal&quot; JavaScript function definition with multiple parameters and turn it into a function that will keep returning a function until all of its parameters have been supplied. Check it out!</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> curry <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda/src/curry'</span>

<span class="hljs-keyword">const</span> oldAdd = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>
  a + b

<span class="hljs-keyword">const</span> add = curry(oldAdd)

add(<span class="hljs-number">10</span>) <span class="hljs-comment">// =&gt; Function</span>
add(<span class="hljs-number">10</span>)(<span class="hljs-number">4</span>) <span class="hljs-comment">// =&gt; 14</span>
add(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// =&gt; 14</span></code></pre><p>Or if you want to have <code>curry</code> baked in to your original <code>add</code> function:</p><pre><code class="hljs js"><span class="hljs-comment">// add :: Number -&gt; Number -&gt; Number</span>
<span class="hljs-keyword">const</span> add = curry((a, b) -&gt;
  a + b
)</code></pre><p>The magical <code>curry</code> function doesn&#39;t care when you provide arguments or how you do so â€“ it will just keep returning you partially applied functions until all arguments have been applied, at which point it will give you back a value.</p><h2><a class="heading--link" name="cool-now-how-does-code-curry-code-work-" href="#cool-now-how-does-code-curry-code-work-"><span>Cool... Now How Does <code>curry</code> Work?</span></a></h2><p>This might seem blasphemous, but to understand how <code>curry</code> works under the hood, we&#39;re going to dive into a different library&#39;s implementation of it: <a href="https://github.com/evilsoft/crocks">crocks</a> by <a href="https://twitter.com/evilsoft">@evilsoft</a>. (Crocks is similar to ramda but dives more into abstract data types (ADTs) and is more towards the deeper end of the Functional Programming pool.) I think crocks&#39; implementation is excellent, and 99% of it being in one file makes for a great teaching tool.</p><p>If you want to jump ahead, here is a link to crocks&#39; <code>curry</code> function: <a href="https://github.com/evilsoft/crocks/blob/master/src/core/curry.js">https://github.com/evilsoft/crocks/blob/master/src/core/curry.js</a></p><p>Where do we start with understanding this next-level JavaScript? Always start with the types, as they can tell a story.</p><h3><a class="heading--link" name="reading-code-curry-code-39-s-story" href="#reading-code-curry-code-39-s-story"><span>Reading <code>curry</code>&#39;s Story</span></a></h3><p>What does this tell us?</p><pre><code class="hljs js"><span class="hljs-comment">// curry :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d</span></code></pre><ol><li><code>((a, b, c) -&gt; d)</code> tells us that it accepts a function that has <em>n</em> parameters of any type and returns a value of any type</li><li><code>-&gt; a -&gt; b -&gt; c</code> tells us that it then accepts each parameter â€“ but only 1 at a time!</li><li><code>-&gt; d</code> tells us that it ultimately returns the value as specified in the function</li></ol><p>Sounds simple, right? Easier said than done!</p><h3><a class="heading--link" name="what-we-need-to-do" href="#what-we-need-to-do"><span>What we need to do</span></a></h3><ol><li>we need to first accept a function (the one to be curried)</li><li>we need to then accept <a href="/blog/simple-variadic-behavior.html">any number of arguments (variadic behavior)</a></li><li>when this happens, we need to either<ul><li>return a value (when all arguments have been applied)</li><li>return a function that accepts the remaining arguments and repeat this condition</li></ul></li></ol><h3><a class="heading--link" name="breaking-down-curry" href="#breaking-down-curry"><span>Breaking Down Curry</span></a></h3><pre><code class="hljs js"><span class="hljs-comment">// curry :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// 1. we accept a function</span>
<span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> {
  <span class="hljs-comment">// 2. we return a function taking any `n` arguments</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> {
    <span class="hljs-comment">// make sure we have a populated list to work with;</span>
    <span class="hljs-comment">// `undefined` is the value for the Unit type in</span>
    <span class="hljs-comment">// crocks and calling our function must utilize some</span>
    <span class="hljs-comment">// sort of value.</span>
    <span class="hljs-keyword">const</span> args =
      xs.length ? xs : [ <span class="hljs-literal">undefined</span> ]

    <span class="hljs-comment">// if the number of args sent are</span>
    <span class="hljs-comment">// less than that required, then</span>
    <span class="hljs-comment">// don't do more work; go ahead and</span>
    <span class="hljs-comment">// return a new version of our function</span>
    <span class="hljs-comment">// that is still waiting for more</span>
    <span class="hljs-comment">// arguments to be applied.</span>
    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) {
      <span class="hljs-comment">// way of safely creating a new function</span>
      <span class="hljs-comment">// and binding arguments to it without</span>
      <span class="hljs-comment">// calling it.</span>
      <span class="hljs-keyword">return</span> curry(<span class="hljs-built_in">Function</span>.bind.apply(fn, [ <span class="hljs-literal">null</span> ].concat(args)))
    }

    <span class="hljs-comment">// if we've provided all arguments,</span>
    <span class="hljs-comment">// then let's apply them and give</span>
    <span class="hljs-comment">// back the result.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// otherwise, let's do some work</span>
    <span class="hljs-comment">// and see if, based on the number</span>
    <span class="hljs-comment">// of arguments, we return a new</span>
    <span class="hljs-comment">// function with fewer arguments</span>
    <span class="hljs-comment">// or go ahead and call the function</span>
    <span class="hljs-comment">// with the final argument so we can</span>
    <span class="hljs-comment">// get back a value.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> `applyCurry` is defined below.</span>
    <span class="hljs-keyword">const</span> val =
      args.length === fn.length
        ? fn.apply(<span class="hljs-literal">null</span>, args)
        : args.reduce(applyCurry, fn)

    <span class="hljs-comment">// 3. if our value is still a function, then</span>
    <span class="hljs-comment">// let's return the curried version of our</span>
    <span class="hljs-comment">// function that still needs some arguments</span>
    <span class="hljs-comment">// to be applied and repeat everything above.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// otherwise, we're all done here, so</span>
    <span class="hljs-comment">// let's return the value.</span>
    <span class="hljs-keyword">return</span> isFunction(val)
      ? curry(val)
      : val
  }
}

<span class="hljs-keyword">const</span> applyCurry = <span class="hljs-function">(<span class="hljs-params">fn, arg</span>) =&gt;</span> {
  <span class="hljs-comment">// return whatever we received if</span>
  <span class="hljs-comment">// fn is actually NOT a function.</span>
  <span class="hljs-keyword">if</span> (!isFunction(fn)) { <span class="hljs-keyword">return</span> fn }

  <span class="hljs-comment">// if we have more than 1 argument</span>
  <span class="hljs-comment">// remaining to be applied, then let's</span>
  <span class="hljs-comment">// bind a value to the next argument and</span>
  <span class="hljs-comment">// keep going.</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// otherwise, then yay let's go ahead</span>
  <span class="hljs-comment">// and call that function with the argument;</span>
  <span class="hljs-comment">// our `[ undefined ]` default saves us from</span>
  <span class="hljs-comment">// some potential headache here.</span>
  <span class="hljs-keyword">return</span> fn.length &gt; <span class="hljs-number">1</span>
    ? fn.bind(<span class="hljs-literal">null</span>, arg)
    : fn.call(<span class="hljs-literal">null</span>, arg)
}

<span class="hljs-keyword">const</span> isFunction = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span>
  <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span></code></pre><p>With all of these checks in here, we can now run the following code and have it all work:</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> add = curry(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b)

add <span class="hljs-comment">// =&gt; Function</span>
add(<span class="hljs-number">1</span>) <span class="hljs-comment">// =&gt; Function</span>
add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// =&gt; 3</span>
add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// =&gt; 3</span>
add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">99</span>) <span class="hljs-comment">// =&gt; 3 (we don't care about the last one!)</span>
add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">99</span>, <span class="hljs-number">2000</span>) <span class="hljs-comment">// =&gt; 3 (we don't care about the last two!)</span></code></pre><h2><a class="heading--link" name="-code-curry-code-in-action" href="#-code-curry-code-in-action"><span><code>curry</code> In Action</span></a></h2><p>If all of your functions are curried, you can start writing code that you never would have been able to before. Here is a small taste that we will cover more fully in a future Ramda Chops:</p><pre><code class="hljs js"><span class="hljs-comment">// addOrRemove :: a -&gt; Array -&gt; Array</span>
<span class="hljs-keyword">const</span> addOrRemove = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span>
  ifElse(
    contains(x),
    without(<span class="hljs-keyword">of</span>(x)),
    append(x)
  )

<span class="hljs-comment">// addOrRemoveTest :: Array -&gt; Array</span>
<span class="hljs-keyword">const</span> addOrRemoveTest =
  addOrRemove(<span class="hljs-string">'test'</span>)

addOrRemoveTest([ <span class="hljs-string">'thing'</span> ]) <span class="hljs-comment">// =&gt; ["thing", "test"]</span>
addOrRemoveTest([ <span class="hljs-string">'thing'</span>, <span class="hljs-string">'test'</span> ]) <span class="hljs-comment">// =&gt; ["thing"]</span></code></pre><p>(<a href="https://goo.gl/5uRhS2">View this example in a live REPL</a>)</p><p>The <code>addOrRemove</code> function almost reads like English: &quot;If something contains <code>x</code>, give me back that something without <code>x</code>; otherwise, append <code>x</code> to that something.&quot; What is worth understanding here is that these functions each accept a number of arguments where <em>the most generic/reusable are provided first</em> (this is a tenet of Functional Programming). Here, we are able to create a very reusable function with partially applied values that sits and waits until the final bit â€“ an array â€“ is provided.</p><hr><p>Thanks for reading! Until next time,<br>Robert</p></div></article><section class="section--padded bg--gray"><div class="layout--constrained"><h2>Get notified of new posts</h2><!-- Begin MailChimp Signup Form --><form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="form"><div id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value=""></div><div class="form__container"><label for="mce-EMAIL" class="form__label">Email Address</label> <input type="email" value="" id="mce-EMAIL" class="form__input" name="EMAIL" placeholder="you@greatemail.com"> <input type="submit" value="Subscribe" name="subscribe" class="form__submit"></div><small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small></form><!--End mc_embed_signup--></div></section></main></body></html>