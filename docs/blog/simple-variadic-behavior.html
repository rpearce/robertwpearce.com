<!DOCTYPE html><html lang="en"><head><title>Simple Variadic Behavior</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta name="description" content="Beginner-friendly introduction to variadic behavior."><meta property="og:site_name" content="Robert Pearce | Freelance Software Developer"><meta property="og:title" content="Simple Variadic Behavior"><meta property="og:url" content="https://robertwpearce.com/blog/simple-variadic-behavior.html"><meta property="og:description" content="Beginner-friendly introduction to variadic behavior."><meta property="og:image" content="/images/waterfall.jpg"><meta property="og:type" content="article"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:site" content="Robert Pearce | Freelance Software Developer"><meta property="twitter:title" content="Simple Variadic Behavior"><meta property="twitter:description" content="Beginner-friendly introduction to variadic behavior."><meta property="twitter:image" content="/images/waterfall.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://robertwpearce.com/blog/simple-variadic-behavior.html"><link rel="stylesheet" href="/styles.css"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><link href="//fonts.googleapis.com/css?family=Lato:400" rel="stylesheet" type="text/css"></head><body><main><nav><div class="layout--constrained"><ul class="nav--main list--bare list--horz"><li><a href="/">Home</a></li><li><a href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a></li></ul></div></nav><article class="article"><div class="article__background" style="background-image: url('/images/waterfall.jpg')"><header class="article__bgHeader"><div class="layout--constrained"><div class="article__bgTitleContainer"><h1 class="heading--trim"><a href="/blog/simple-variadic-behavior.html">Simple Variadic Behavior</a></h1><div class="article__subHeader"><small>Oct 13, 2015</small></div></div></div></header></div><div class="layout--constrained"><header class="article__header heading--fatBottomBorder"><h1 class="heading--trim"><a href="/blog/simple-variadic-behavior.html">Simple Variadic Behavior</a></h1><small>Oct 13, 2015</small></header><p class="strikethrough">Recently, I have started working on my own static site generator, <a href="https://github.com/rpearce/react-static">react-static</a>, to accomodate my markdown blog posting &amp; static site needs. Another benefit is that I get to work on my Node.js and ES2015+ JavaScript skills. While I am reinventing the wheel on some levels, it is good practice.</p><p><strong>Update</strong>: I made a library, <a href="https://www.npmjs.com/package/parse-md">parse-md</a>, out of some of this behavior in order to address the need of parsing metadata from markdown files.</p><p>My latest problem to solve was how, once I had a <code>.md</code> (Markdown) file&#39;s contents, to go about parsing out the blog post&#39;s metadata (see below: the key/value pairs between the two <code>---</code>s).</p><pre><code class="hljs markdown">---
title: This is a test
<span class="hljs-section">description: Once upon a time, there was a test...
---</span>

<span class="hljs-section"># Title of my great post</span>
Lorem ipsum dolor...

<span class="hljs-section">## Some heading</span>
Bacon ipsum...
</code></pre><p>Once I <code>split</code> this file based on newlines, I needed a way of finding the indices of the metadata boundary, <code>---</code>, so that I could <code>splice</code> the array in to two pieces and be on my way. My first attempt at getting the indices looked like this:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetadataIndices</span>(<span class="hljs-params">lines</span>) </span>{
  <span class="hljs-keyword">var</span> arr = [];
  lines.forEach(<span class="hljs-function">(<span class="hljs-params">line, i</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^---/</span>.test(line)) {
      arr.push(i);
    }
  });
  <span class="hljs-keyword">return</span> arr;
}

getMetadataIndices(lines); <span class="hljs-comment">// [0, 3]</span>
</code></pre><p>This is a simple solution that any junior dev can do, and it accomplishes the task... but it doesn&#39;t feel right. I am iterating over each item, testing each line and mutating an array variable when a condition is true. While it doesn&#39;t look like much, that is a good bit going on all at once. Instinct tells me that each action could be its own simple method. I also don&#39;t want to use a temporary variable that I mutate. However, this removes <code>forEach</code> from our options, as <code>forEach</code> returns the original array. <code>map()</code> to the rescue! (or so we think).</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetadataIndices</span>(<span class="hljs-params">lines</span>) </span>{
  <span class="hljs-keyword">return</span> lines.map(testForBoundary);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testForBoundary</span>(<span class="hljs-params">item, i</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^---/</span>.test(item)) {
    <span class="hljs-keyword">return</span> i;
  }
}

getMetadataIndices(lines); <span class="hljs-comment">// [0, undefined, undefined, 3, undefined, undefined, undefined, undefined, undefined, undefined]</span>
</code></pre><p>Crap. Because I only return when the test is true, <code>map</code> doesn&#39;t know what to return, so it returns <code>undefined</code> and moves on. It would be nice if we could clean out these <code>undefined</code>s!</p><h2><a class="heading--link" name="cleaning-up-our-array" href="#cleaning-up-our-array"><span>Cleaning Up Our Array</span></a></h2><p>How can we achieve the following desired functionality?</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetadataIndices</span>(<span class="hljs-params">lines</span>) </span>{
  <span class="hljs-keyword">return</span> lines.map(testForBoundary).clean(<span class="hljs-literal">undefined</span>);
}

getMetadataIndices(lines); <span class="hljs-comment">// [0, 3]</span>
</code></pre><p>Let&#39;s make a function on the <code>prototype</code> of <code>Array</code> called <code>clean</code>:</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.clean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trash</span>) </span>{
};
</code></pre><p>Here, we access <code>Array</code>&#39;s <code>prorotype</code> and add our own custom method, <code>clean</code> and pass it one argument. Next, we need to <code>filter</code> out all of the <code>undefined</code>s in our array.</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.clean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trash</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== trash);
};
</code></pre><p>But what if we need to clean more than one value out? What if we need to clean <code>null</code>, <code>&quot;&quot;</code> and <code>undefined</code>?</p><h2><a class="heading--link" name="variadic-behavior" href="#variadic-behavior"><span>Variadic Behavior</span></a></h2><p>In JavaScript, <em>variadic behavior</em> is a fancy term applied to functions that can accept and handle any number of arguments, and these are typically accessed within the function via the <code>arguments</code> object, which looks like an <code>Array</code> but is <em>not</em>. For example, this code will give you an error about <code>indexOf</code> not being defined on <code>arguments</code>.</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.clean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trash</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">arguments</span>.indexOf(item) === <span class="hljs-number">-1</span>);
};
</code></pre><p>Drats! <code>arguments</code> is very similar to an array &mdash; how can we get this to work? <code>slice</code> to the rescue!</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.clean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> args.indexOf(item) === <span class="hljs-number">-1</span>);
};
</code></pre><p>Without any additional arguments, <code>slice</code> makes a copy of an array and allows us to provide a custom receiver of array-like functionality: <code>arguments</code>. What is returned from the second line above is an array-ized <em>copy</em> of <code>arguments</code>. Now that <code>args</code> is an array of all the arguments that are passed to <code>clean</code>, we can pass as many options as we would like to clean out our array!</p><p>Here is more example usage of such a method:</p><pre><code class="hljs js"><span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">""</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"yes"</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">""</span>];
arr.clean(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// ["", 3, "yes", ""];</span>
arr.clean(<span class="hljs-literal">undefined</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// [3, "yes"];</span>
</code></pre><h2><a class="heading--link" name="all-together" href="#all-together"><span>All Together</span></a></h2><p>In attempting to refactor some fairly simple, though multiple-responsibility code, we end up creating a few reusable functions that will benefit us in the future, and we make our code more maintainable, testable and readable in the end. Here it is once we have finished:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetadataIndices</span>(<span class="hljs-params">lines</span>) </span>{
  <span class="hljs-keyword">return</span> lines.map(testForBoundary).clean(<span class="hljs-literal">undefined</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testForBoundary</span>(<span class="hljs-params">item, i</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^---/</span>.test(item)) {
    <span class="hljs-keyword">return</span> i;
  }
}

<span class="hljs-built_in">Array</span>.prototype.clean = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> args.indexOf(item) === <span class="hljs-number">-1</span>);
};
</code></pre><p>But could this be done <em>even</em> simpler?</p><h2><a class="heading--link" name="p-s-use-reduce-next-time" href="#p-s-use-reduce-next-time"><span>p.s. Use reduce next time</span></a></h2><p>You may have been wondering why we didn&#39;t use <code>reduce</code> like this from the start:</p><pre><code class="hljs js">lines.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">mem, item, i</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^---/</span>.test(item)) {
    mem.push(i);
  }
  <span class="hljs-keyword">return</span> mem;
});
</code></pre><p>or, cleaned up a bit,</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMetadataIndices</span>(<span class="hljs-params">mem, item, i</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^---/</span>.test(item)) {
    mem.push(i);
  }
  <span class="hljs-keyword">return</span> mem;
}

lines.reduce(getMetadataIndices, []);
</code></pre><p>Surprise! We totally could have, but since <code>reduce</code> was not our first thought when refactoring, we managed to solve our problem in another way. There are 1000 ways to solve problems, and sometimes you don&#39;t think of the best one first, but you can still make the best with what you have at the time and refactor later.</p></div></article><section class="section--padded bg--gray"><div class="layout--constrained"><h2>Get Updates</h2><!-- Begin MailChimp Signup Form --><form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="form"><div id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px" aria-hidden="true"><input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value=""></div><div class="form__container"><label for="mce-EMAIL" class="form__label">Email Address</label><input type="email" value="" id="mce-EMAIL" class="form__input" name="EMAIL" placeholder="you@greatemail.com"> <input type="submit" value="Subscribe" name="subscribe" class="form__submit"></div><small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small></form><!--End mc_embed_signup--></div></section></main></body></html>