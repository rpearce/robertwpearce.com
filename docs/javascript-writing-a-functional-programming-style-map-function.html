<!DOCTYPE html>
<html lang="en">
  <head>
    <title>JavaScript: Writing a Functional Programming-Style map Function</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors.">
    <meta name="author" content="Robert Pearce">
    <meta name="keywords" content="javascript, map, map function, functional programming, js, programming">
    <meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU">

    <meta property="og:site_name" content="Robert Pearce | Senior Software Developer">
    <meta property="og:title" content="JavaScript: Writing a Functional Programming-Style map Function">
    <meta property="og:url" content="https://robertwpearce.com/javascript-writing-a-functional-programming-style-map-function.html">
    <meta property="og:description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors.">
    <meta property="og:image" content="https://robertwpearce.com/images/queenstown-wharf.jpg">
    
      <meta property="og:type" content="article">
    

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:site" content="Robert Pearce | Senior Software Developer">
    <meta property="twitter:title" content="JavaScript: Writing a Functional Programming-Style map Function">
    <meta property="twitter:description" content="Learn how to write a generic map function to map Arrays, Objects, and Functors.">
    <meta property="twitter:image" content="https://robertwpearce.com/images/queenstown-wharf.jpg">
    <meta property="twitter:creator" content="@RobertWPearce">

    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="canonical" href="https://robertwpearce.com/javascript-writing-a-functional-programming-style-map-function.html">
    <link rel="stylesheet" href="/css/default.css" />
    
      <link rel="stylesheet" href="/css/article.css" />
    
  </head>
  <body class="light">
    <nav class="nav">
  <div class="layout--constrained" data-nav-wrap>
    <a class="nav__link nav__skip" href="#content">Skip to content</a>
    <a class="nav__link" href="/">Home</a>
    <a class="nav__link" href="mailto:me@robertwpearce.com?subject=Work Inquiry">Hire Me</a>
    <a class="nav__link" href="/atom.xml">atom</a>
    <a class="nav__link" href="/rss.xml">rss</a>
  </div>
</nav>


<main id="content" tabindex="-1">
  <article class="article">
    <header class="article__bg" style="background-image: url('/images/queenstown-wharf.jpg')">
      <div class="article__bgHeader">
        <div class="layout--constrained">
          <div class="article__bgTitleWrap">
            <h1 class="article__bgTitle">
              <a href="/javascript-writing-a-functional-programming-style-map-function.html">JavaScript: Writing a Functional Programming-Style map Function</a>
            </h1>
            <div class="article__bgSubHeader">
              <small class="italic">2020-02-20</small>
              
              
              <small class="article__bgPhotoCred italic">
                [ photo credit <a href="https://www.instagram.com/emilycouldmakethat">emilycouldmakethat</a> ]
              </small>
              
            </div>
          </div>
        </div>
      </div>
    </header>
    <section class="layout--constrained">
      <header class="article__header">
        <h1 class="article__title">
          <a href="/javascript-writing-a-functional-programming-style-map-function.html">JavaScript: Writing a Functional Programming-Style map Function</a>
        </h1>
        <small class="italic">2020-02-20</small>
        
      </header>
      <p><em>Many thanks to <a href="https://twitter.com/goodforenergy">Helen Durrant</a> for reviewing this post and offering stellar suggestions.</em></p>
<p>In this post, we will write a functional programming-style implementation of JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map</code></a> function that not only works with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a> but any data structure that implements a <code>map</code> method. Such data structures are known as <a href="https://github.com/hemanth/functional-programming-jargon#functor"><code>Functors</code></a>. Some examples of <code>Functors</code> are the algebraic data types<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a> and <a href="https://crocks.dev/docs/crocks/Async.html"><code>Async</code></a> (prior knowledge of them is not required, and out of the two, we’ll only use <code>Maybe</code>).</p>
<p>By the end of this post, you will:</p>
<ul>
<li>know how to implement a generic <code>map</code> function that includes functions for <code>map</code>ping <code>Array</code>s, <code>Object</code>s, and <code>Functor</code>s</li>
<li>understand how to use <code>map</code> in a variety of scenarios</li>
<li>know how to write a simple <code>compose</code> function and use composition</li>
<li>know how to reliably test values for their types</li>
<li>have received a small introduction to algebraic data types via the <a href="https://crocks.dev"><code>crocks</code></a> library</li>
</ul>
<p>This is a big post, so buckle up! If you want to see the final product, check out this CodeSandbox: <a href="https://codesandbox.io/s/bitter-grass-tknwb" class="uri">https://codesandbox.io/s/bitter-grass-tknwb</a>.</p>
<hr />
<p><em>Note: if you’re not familiar with <code>Array.prototype.map</code> already, check out my video on <a href="https://www.youtube.com/watch?v=tjjg3_jyD7M">Using JavaScript’s Array.prototype.map Method</a> or my post on <a href="https://robertwpearce.com/javascript-understand-array-prototype-map-by-reimplementing-it.html">JavaScript: Understand Array.prototype.map by Reimplementing It</a>.</em></p>
<p><em>We will use the implementation of the <code>map</code> function in <a href="https://crocks.dev">crocks</a> as our template, so if you want to skip this article entirely, you can go and view <a href="https://github.com/evilsoft/crocks/blob/e4517493079538960d53715ef25d72c264cfecf0/src/pointfree/map.js#L15-L38">its source</a>.</em></p>
<h2 id="overview">Overview</h2>
<ol>
<li><a href="#the-goal-map-all-the-things">The Goal: <code>map</code> All the Things</a></li>
<li><a href="#defining-our-map-function">Defining Our <code>map</code> Function</a></li>
<li><a href="#map-an-array"><code>map</code> an <code>Array</code></a></li>
<li><a href="#map-an-object"><code>map</code> an <code>Object</code></a></li>
<li><a href="#map-a-function"><code>map</code> a <code>Function</code></a></li>
<li><a href="#map-a-functor"><code>map</code> a <code>Functor</code></a></li>
<li><a href="#throwing-out-bad-data"><code>throw</code>ing Out Bad Data</a></li>
</ol>
<h2 id="the-goal-map-all-the-things">The Goal: <code>map</code> All the Things</h2>
<p>Today we are going to write a <code>map</code> function that does the following:</p>
<ul>
<li>accepts a transformation function that takes in some argument of type <code>a</code> and transforms it into a value of type <code>b</code>; i.e., <code>(a -&gt; b)</code></li>
<li>accepts and handles any of the following data types:
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></li>
<li><a href="https://github.com/hemanth/functional-programming-jargon#functor"><code>Functors</code></a> (e.g., <a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a>)</li>
</ul></li>
</ul>
<p>Sounds easy, right? We’ll see!</p>
<h2 id="defining-our-map-function">Defining Our <code>map</code> Function</h2>
<p>There are some things we already know about our <code>map</code> function:</p>
<ul>
<li>it’s called <code>map</code> (yay! nailed it!)</li>
<li>it takes a function (<code>fn</code>) and then some datum (<code>m</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li>
<li>it returns the data as transformed by said function</li>
</ul>
<p>Let’s sketch it out:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">const</span> map <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="co">// ???</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">}</span></span></code></pre></div>
<p>Okay, it’s a start. This could conceivably be used like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">id</span><span class="op">,</span> [<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>])     <span class="co">// [1, 2]</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">id</span><span class="op">,</span> [<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;a&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;b&#39;</span> <span class="op">}</span>]) <span class="co">// [&#39;a&#39;, &#39;b&#39;]</span></span></code></pre></div>
<p>Note the repetition of the <code>x =&gt; x.id</code>. Let’s try pulling it out into a variable:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">const</span> propId <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">id</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="at">map</span>(propId<span class="op">,</span> [<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>])     <span class="co">// [1, 2]</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="at">map</span>(propId<span class="op">,</span> [<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;a&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;b&#39;</span> <span class="op">}</span>]) <span class="co">// [&#39;a&#39;, &#39;b&#39;]</span></span></code></pre></div>
<p>Alas, that’s not much better – now we’re just repeating the variable!</p>
<p>Instead, what if we could store our combination of function and <code>map</code> in a variable and then use that to call with our different data? By <a href="https://github.com/hemanth/functional-programming-jargon#partial-application"><em>partially applying</em></a> the function to <code>map</code>, we can!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">const</span> mapId <span class="op">=</span> <span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">id</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="at">mapId</span>([<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>])     <span class="co">// [1, 2]</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="at">mapId</span>([<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;a&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;b&#39;</span> <span class="op">}</span>]) <span class="co">// [&#39;a&#39;, &#39;b&#39;]</span></span></code></pre></div>
<p>Nice! Now, let’s go back to our sketch. Let’s turn our <em>binary</em> function (which takes <em>two</em> parameters) to instead be a series of <em>unary</em> functions (which take <em>one</em> parameter<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="co">// ???</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="op">}</span></span></code></pre></div>
<p>Wow, that was easy. By default, languages like <a href="http://learnyouahaskell.com/higher-order-functions">Haskell</a> and <a href="https://guide.elm-lang.org">Elm</a> automatically <a href="https://robertwpearce.com/ramda-chops-function-currying.html">curry</a> all of their function parameters. There are <a href="https://robertwpearce.com/ramda-chops-function-currying.html">ways to automate that in JavaScript</a>, but for today, we will <em>manually</em> curry functions by using arrow functions to simulate it: <code>const sum = a =&gt; b =&gt; a + b</code>, for example.</p>
<p>Lastly, on the function definition side, it would be helpful for readers of our code to understand more about the intended types. In lieu of JavaScript not having a static type checker and me not knowing <a href="https://www.typescriptlang.org/">TypeScript</a> yet, we’ll do this using a Haskell-style pseudo-type signature:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="fu">map</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>And we can place that as a comment above our function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="co">// ???</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">}</span></span></code></pre></div>
<p>Woah, woah, woah! What’s all this? Let’s break it down.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">map</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">--  |     |            |     |   |      |</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">--  1     2            3     4   5      6</span></span></code></pre></div>
<ol>
<li>Can be read, “has the type of”</li>
<li>Anything after <code>::</code> and before <code>=&gt;</code> in a signature is a <a href="http://www.learnyouahaskell.com/types-and-typeclasses">class constraint</a>. This says we’re going to use something in the type signature that obeys the Functor Laws<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, <em>identity</em> and <a href="https://robertwpearce.com/ramda-chops-function-composition.html"><em>composition</em></a>. The lowercase <code>f</code> represents what the <code>Functor</code> will be in the signature.</li>
<li>Our <code>map</code>ping function; e.g., <code>x =&gt; x.id</code>, like we did above.</li>
<li><code>-&gt;</code> Arrows are used in type signatures to say “then return…”. In our <code>map</code> signature, we say, “We accept a function from <code>a</code> to <code>b</code> then return a function that accepts <code>f</code> of <code>a</code> and then return <code>f</code> of <code>b</code>”. If we were summing three numbers, <code>sum3 :: Number -&gt; Number -&gt; Number -&gt; Number</code>, this would read, “<code>sum3</code> has the type of an expression that accepts a <code>Number</code> that returns a function that accepts a <code>Number</code> then returns a function that accepts a <code>Number</code> and then returns a <code>Number</code>.”</li>
<li><code>f a</code> says that a <code>Functor</code>, <code>f</code>, wraps some other type, <code>a</code>. A concrete example of this is <code>[Number]</code>, which is a list (or <code>Array</code>) of <code>Number</code>s.</li>
<li><code>f b</code> says that a <code>Functor</code>, <code>f</code>, wraps some other type, <code>b</code>. Why isn’t it <code>a</code>? This signifies that when we take in the <code>Functor</code> of any type <code>a</code>, it’s totally cool if you want to change the return type inside the <code>Functor</code>. For example, when we take <code>[{ id: 'a' }, { id: 'b' }]</code> and use <code>map</code> to turn that into <code>['a', 'b']</code>, we’re taking <code>[Object]</code> (a list of <code>Object</code>s) and turning that into <code>[String]</code> (a list of <code>String</code>s).</li>
</ol>
<p>All together now! “<code>map</code> has the type of an expression where <code>f</code> is a <code>Functor</code>, and it accepts a function from <code>a</code> to <code>b</code>, then returns a function that accepts <code>f</code> of <code>a</code>, and then returns <code>f</code> of <code>b</code>.”</p>
<h2 id="map-an-array"><code>map</code> an <code>Array</code></h2>
<p>Let’s <code>map</code> an <code>Array</code>!</p>
<p>Remember our <code>Functor</code> class constraint?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="fu">map</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Guess what? <code>Array</code> is a <code>Functor</code>s! How? It adheres to the laws of <em>identity</em> and <em>composition</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">// identity</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(x <span class="kw">=&gt;</span> x) <span class="co">// [1,2,3]</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">// composition</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">const</span> add10 <span class="op">=</span> x <span class="kw">=&gt;</span> x <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">const</span> mult2 <span class="op">=</span> x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(add10).<span class="at">map</span>(mult2)     <span class="co">// [ 22, 24, 26 ]</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co">// is equivalent to...</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="at">mult2</span>(<span class="at">add10</span>(x))) <span class="co">// [ 22, 24, 26 ]</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">// another example of the composition law</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">const</span> compose <span class="op">=</span> (f<span class="op">,</span> g) <span class="kw">=&gt;</span> x <span class="kw">=&gt;</span> <span class="at">f</span>(<span class="at">g</span>(x))</span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="at">mult2</span>(<span class="at">add10</span>(<span class="dv">2</span>)) <span class="op">===</span> <span class="at">compose</span>(mult2<span class="op">,</span> add10)(<span class="dv">2</span>) <span class="co">// true</span></span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="co">// and applied back to our prior example</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(add10).<span class="at">map</span>(mult2)      <span class="co">// [ 22, 24, 26 ]</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="at">mult2</span>(<span class="at">add10</span>(x)))  <span class="co">// [ 22, 24, 26 ]</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>].<span class="at">map</span>(<span class="at">compose</span>(mult2<span class="op">,</span> add10)) <span class="co">// [ 22, 24, 26 ]</span></span></code></pre></div>
<p>Through <code>map</code>, <code>Array</code> is a <code>Functor</code>. A way to quickly determine if something is a <code>Functor</code> is to ask, “Does it implement <code>map</code> / is it <code>map</code>pable?”</p>
<p>Since we know that <code>Array</code> is <code>map</code>pable, we can use our <code>map</code> function to check if the <code>f a</code> parameter is an <code>Array</code> and then use the build in <code>Array.prototype.map</code> function to get from <code>a</code> to <code>b</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="cf">if</span> (<span class="at">isArray</span>(m)) <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="cf">return</span> <span class="at">mapArray</span>(fn<span class="op">,</span> m)</span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span class="op">}</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co">// isArray :: a -&gt; Bool</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">const</span> isArray <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="va">Array</span>.<span class="at">isArray</span>(x)</span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">const</span> mapArray <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="va">m</span>.<span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="at">fn</span>(x))</span></code></pre></div>
<p>Here, we use <code>Array.isArray()</code><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> to see if the argument, <code>m</code>, is an <code>Array</code>, then we call a function, <code>mapArray</code>, that handles the <code>map</code>ping of the <code>Array</code>.</p>
<p><em>You might be thinking: why <code>m.map(x =&gt; fn(x))</code> and not <code>m.map(fn)</code>? As you might remember from <a href="https://robertwpearce.com/javascript-understand-array-prototype-map-by-reimplementing-it.html">my article on re-implementing <code>Array.prototype.map</code></a>, there are a few other arguments that the native implementation of <code>map</code> provide, as well as some potential changes to the <code>this</code> keyword in your callback function scope. Instead of allowing those to pass through, we simply take the first argument, the currently iterated value, and send that to the callback function<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</em></p>
<p>Now that we’ve seen the easy way to do <code>map</code> with <code>Array</code>, let’s see what this would look like if we felt like implementing <code>mapArray</code> ourselves:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">const</span> mapArray <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">const</span> newArray <span class="op">=</span> []</span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">m</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    newArray[i] <span class="op">=</span> <span class="at">fn</span>(m[i])</span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>  <span class="cf">return</span> newArray</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="op">}</span></span></code></pre></div>
<p>Not too shabby! All we do is create a new <code>Array</code> and set the results of calling the callback function with each item to its index in the new <code>Array</code> and then return that <code>Array</code>.</p>
<p>Do you think our <code>map</code> function can handle an <code>Array</code> of <code>Array</code>s?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span>)([ [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]<span class="op">,</span> [<span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">,</span> [<span class="dv">5</span><span class="op">,</span><span class="dv">6</span>] ])</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">// Array(3) [ NaN, NaN, NaN ]</span></span></code></pre></div>
<p>While we can successfully iterate over the 3 items in the top-level <code>Array</code>, our callback function can’t perform operations like <code>[1,2] * 2</code>! We need to do another <code>map</code> on the nested <code>Array</code>s:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1"></a><span class="at">map</span>(<span class="at">map</span>(x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span>))([ [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]<span class="op">,</span> [<span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">,</span> [<span class="dv">5</span><span class="op">,</span><span class="dv">6</span>] ])</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">// [ [2,4], [6,8], [10,12] ]</span></span></code></pre></div>
<p>Well done! What else can you <code>map</code>? We’re now going to leave charted waters and venture into the unknown.</p>
<h2 id="map-an-object"><code>map</code> an <code>Object</code></h2>
<p>Let’s say we have an <code>i18n</code> (short for “internationalization”) object that we’ve been given that has a terribly annoying issue: every translation is prefixed and suffixed with an underscore (<code>_</code>)!</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">const</span> i18n <span class="op">=</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="st">&#39;en-US&#39;</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="dt">dayMode</span><span class="op">:</span> <span class="st">&#39;_Day mode_&#39;</span><span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">greeting</span><span class="op">:</span> <span class="st">&#39;_Hello!_&#39;</span><span class="op">,</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="dt">nightMode</span><span class="op">:</span> <span class="st">&#39;_Night Mode_&#39;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="op">},</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>  <span class="st">&#39;es-ES&#39;</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>    <span class="dt">dayMode</span><span class="op">:</span> <span class="st">&#39;_Modo día_&#39;</span><span class="op">,</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="dt">greeting</span><span class="op">:</span> <span class="st">&#39;_¡Hola!_&#39;</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="dt">nightMode</span><span class="op">:</span> <span class="st">&#39;_Modo nocturno_&#39;</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>  <span class="op">}</span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="op">}</span></span></code></pre></div>
<p>We could manually delete each one, or we could find and replace with our text editor, or we could write a <code>for</code> loop to do this, but because we’re super awesome functional programmers, we’ll try to <code>map</code> over the <code>Object</code> and write a function that removes the prefixed &amp; suffixed underscores (…then we copy and paste that? work with me here!).</p>
<p>Before we can do this, we need to see what happens when we call <code>.map()</code> on an <code>Object</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1"></a>i18n[<span class="st">&#39;en-US&#39;</span>].<span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">slice</span>(<span class="dv">1</span>))</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">// TypeError: i18n[&#39;en-US&#39;].map is not a function</span></span></code></pre></div>
<p>Oh no! If we can’t even fix the <code>en-US</code> <code>Object</code>, how are we supposed to fix <em>all</em> of them? Let’s update our <code>map</code> function to handle <code>Object</code>s.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="cf">if</span> (<span class="at">isArray</span>(m)) <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="cf">return</span> <span class="at">mapArray</span>(fn<span class="op">,</span> m)</span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="op">}</span></span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="cf">if</span> (<span class="at">isObject</span>(m)) <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="cf">return</span> <span class="at">mapObject</span>(fn<span class="op">,</span> m)</span>
<span id="cb17-9"><a href="#cb17-9"></a>  <span class="op">}</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11"></a></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="co">// isObject :: a -&gt; Bool</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="kw">const</span> isObject <span class="op">=</span> x <span class="kw">=&gt;</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>  <span class="op">!!</span>x <span class="op">&amp;&amp;</span> <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(x) <span class="op">===</span> <span class="st">&#39;[object Object]&#39;</span></span>
<span id="cb17-15"><a href="#cb17-15"></a></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="co">// mapObject :: ((a -&gt; b), { k: a }) -&gt; { k: b }</span></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="kw">const</span> mapObject <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>  <span class="kw">const</span> obj <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb17-19"><a href="#cb17-19"></a></span>
<span id="cb17-20"><a href="#cb17-20"></a>  <span class="cf">for</span> (<span class="kw">const</span> [k<span class="op">,</span> v] <span class="kw">of</span> <span class="va">Object</span>.<span class="at">entries</span>(m)) <span class="op">{</span></span>
<span id="cb17-21"><a href="#cb17-21"></a>    obj[k] <span class="op">=</span> <span class="at">fn</span>(v)</span>
<span id="cb17-22"><a href="#cb17-22"></a>  <span class="op">}</span></span>
<span id="cb17-23"><a href="#cb17-23"></a></span>
<span id="cb17-24"><a href="#cb17-24"></a>  <span class="cf">return</span> obj</span>
<span id="cb17-25"><a href="#cb17-25"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we test if something is an object by using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString</code></a> and make sure to <code>.call(x)</code> instead of just <code>.toString(x)</code>, for this reason:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1"></a><span class="va">Object</span>.<span class="va">prototype</span>.<span class="at">toString</span>(<span class="kw">null</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="co">// &quot;[object Object]&quot;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(<span class="kw">null</span>)</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co">// &quot;[object Null]&quot;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="va">Object</span>.<span class="va">prototype</span>.<span class="at">toString</span>([])</span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">// &quot;[object Object]&quot;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>([])</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="co">// &quot;[object Array]&quot;</span></span>
<span id="cb18-12"><a href="#cb18-12"></a></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(<span class="op">{}</span>)</span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="co">// &quot;[object Object]&quot;</span></span></code></pre></div>
<p>We then use our new <code>mapObject</code> function, whose signature is</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">mapObject ::</span> ((a <span class="ot">-&gt;</span> b), { k<span class="op">:</span> a }) <span class="ot">-&gt;</span> { k<span class="op">:</span> b }</span></code></pre></div>
<p><code>mapObject</code> takes a function from <code>a</code> to <code>b</code> and an <code>Object</code> with a key(s) and some value(s), <code>a</code>, and returns an <code>Object</code> with a key(s) and some value(s) <code>b</code>. In short, it maps the <em>values</em> of an <code>Object</code>. Our <code>mapObject</code> function is nothing more than a <code>for</code> loop over each value returned from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries()</code></a>! It calls the callback function with each value and returns a new object with the same key and a new, updated value.</p>
<p>Let’s try it out:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">const</span> i18n <span class="op">=</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="st">&#39;en-US&#39;</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="dt">dayMode</span><span class="op">:</span> <span class="st">&#39;_Day mode_&#39;</span><span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="dt">greeting</span><span class="op">:</span> <span class="st">&#39;_Hello!_&#39;</span><span class="op">,</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="dt">nightMode</span><span class="op">:</span> <span class="st">&#39;_Night Mode_&#39;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>  <span class="op">},</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>  <span class="st">&#39;es-ES&#39;</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="dt">dayMode</span><span class="op">:</span> <span class="st">&#39;_Modo día_&#39;</span><span class="op">,</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="dt">greeting</span><span class="op">:</span> <span class="st">&#39;_¡Hola!_&#39;</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="dt">nightMode</span><span class="op">:</span> <span class="st">&#39;_Modo nocturno_&#39;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>  <span class="op">}</span></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="op">}</span></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">slice</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">-1</span>))(i18n[<span class="st">&#39;en-US&#39;</span>])</span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="co">// {</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="co">//   dayMode: &#39;Day mode&#39;,</span></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="co">//   greeting: &#39;Hello!&#39;,</span></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="co">//   nightMode: &#39;Night Mode&#39;</span></span>
<span id="cb20-18"><a href="#cb20-18"></a><span class="co">// }</span></span></code></pre></div>
<p>Okay – what about our entire <code>i18n</code> object?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1"></a><span class="at">map</span>(<span class="at">map</span>(x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">slice</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">-1</span>)))(i18n)</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="co">// {</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co">//  &#39;en-US&#39;: {</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co">//    dayMode: &#39;Day mode&#39;,</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="co">//    greeting: &#39;Hello!&#39;,</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="co">//    nightMode: &#39;Night Mode&#39;</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="co">//  },</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="co">//  &#39;es-ES&#39;: {</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="co">//    dayMode: &#39;Modo día&#39;,</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="co">//    greeting: &#39;¡Hola!&#39;,</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="co">//    nightMode: &#39;Modo nocturno&#39;</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="co">//  }</span></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="co">// }</span></span></code></pre></div>
<p>Since we’re dealing with nested objects, we need to use <code>map</code> on an <code>Object</code> inside an <code>Object</code>. We pass a nested <code>map</code>ping function, and our little underscore problem is gone!</p>
<h2 id="map-a-function"><code>map</code> a <code>Function</code></h2>
<p>Remember our functions <code>mult2</code> and <code>add10</code> from before?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">const</span> add10 <span class="op">=</span> x <span class="kw">=&gt;</span> x <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">const</span> mult2 <span class="op">=</span> x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span></span></code></pre></div>
<p>What would happen if we used those as the arguments to our <code>map</code> function and wanted them to be automatically composed together so that we can then provide a value later?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1"></a><span class="at">map</span>(add10)(mult2)     <span class="co">// undefined</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="at">map</span>(add10)(mult2)(<span class="dv">12</span>) <span class="co">// TypeError: map(...)(...) is not a function</span></span></code></pre></div>
<p>Time for our <code>map</code> function to handle a <code>Function</code> as the second argument and <code>compose</code> the two functions together:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="cf">if</span> (<span class="at">isArray</span>(m)) <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="cf">return</span> <span class="at">mapArray</span>(fn<span class="op">,</span> m)</span>
<span id="cb24-5"><a href="#cb24-5"></a>  <span class="op">}</span></span>
<span id="cb24-6"><a href="#cb24-6"></a></span>
<span id="cb24-7"><a href="#cb24-7"></a>  <span class="cf">if</span> (<span class="at">isObject</span>(m)) <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="cf">return</span> <span class="at">mapObj</span>(fn<span class="op">,</span> m)</span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="op">}</span></span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a>  <span class="cf">if</span> (<span class="at">isFunction</span>(m)) <span class="op">{</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="cf">return</span> <span class="at">compose</span>(fn<span class="op">,</span> m)</span>
<span id="cb24-13"><a href="#cb24-13"></a>  <span class="op">}</span></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="op">}</span></span>
<span id="cb24-15"><a href="#cb24-15"></a></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="co">// isFunction :: a -&gt; Bool</span></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="kw">const</span> isFunction <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="kw">typeof</span> x <span class="op">===</span> <span class="st">&#39;function&#39;</span></span>
<span id="cb24-18"><a href="#cb24-18"></a></span>
<span id="cb24-19"><a href="#cb24-19"></a><span class="co">// compose :: ((b -&gt; c), (a -&gt; b)) -&gt; a -&gt; c</span></span>
<span id="cb24-20"><a href="#cb24-20"></a><span class="kw">const</span> compose <span class="op">=</span> (f<span class="op">,</span> g) <span class="kw">=&gt;</span> x <span class="kw">=&gt;</span> <span class="at">f</span>(<span class="at">g</span>(x))</span></code></pre></div>
<p>And when we run our previously failed code again,</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1"></a><span class="at">map</span>(add10)(mult2)     <span class="co">// function compose(x)</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="at">map</span>(add10)(mult2)(<span class="dv">12</span>) <span class="co">// 44</span></span></code></pre></div>
<p>we can see that calling <code>map</code> with two functions returns a composition of those two functions, and calling that result with a primitive value (<code>12</code>) gives us back our result, <code>44</code>.</p>
<h2 id="map-a-functor"><code>map</code> a <code>Functor</code></h2>
<p>When we learned about <code>map</code>ping <code>Array</code>s before, we learned that <code>Array</code>s are <code>Functor</code>s because they adhere to the laws of <em>identity</em> and <em>composition</em>; i.e., they are <code>map</code>pable.</p>
<p>There are all sorts of other data structures that implement a <code>map</code> method, just like <code>Array.prototype</code> does, and we want to be able to handle those, too!</p>
<p>We currently have all the tools required to implement <code>map</code> for <code>Functor</code>s without even knowing how they might work! All we need to know is, “Does it implement <code>map</code> as a <code>Function</code>?” Let’s see what we can come up with!</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="cf">if</span> (<span class="at">isFunction</span>(m)) <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="cf">return</span> <span class="at">compose</span>(fn<span class="op">,</span> m)</span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="op">}</span></span>
<span id="cb26-6"><a href="#cb26-6"></a></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="cf">if</span> (<span class="at">isArray</span>(m)) <span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="cf">return</span> <span class="at">mapArray</span>(fn<span class="op">,</span> m)</span>
<span id="cb26-9"><a href="#cb26-9"></a>  <span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a>  <span class="cf">if</span> (<span class="at">isFunctor</span>(m)) <span class="op">{</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>    <span class="cf">return</span> <span class="at">mapFunctor</span>(fn<span class="op">,</span> m)</span>
<span id="cb26-13"><a href="#cb26-13"></a>  <span class="op">}</span></span>
<span id="cb26-14"><a href="#cb26-14"></a></span>
<span id="cb26-15"><a href="#cb26-15"></a>  <span class="cf">if</span> (<span class="at">isObject</span>(m)) <span class="op">{</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>    <span class="cf">return</span> <span class="at">mapObj</span>(fn<span class="op">,</span> m)</span>
<span id="cb26-17"><a href="#cb26-17"></a>  <span class="op">}</span></span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="op">}</span></span>
<span id="cb26-19"><a href="#cb26-19"></a></span>
<span id="cb26-20"><a href="#cb26-20"></a><span class="co">// isFunction :: a -&gt; Bool</span></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="kw">const</span> isFunction <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="kw">typeof</span> x <span class="op">===</span> <span class="st">&#39;function&#39;</span></span>
<span id="cb26-22"><a href="#cb26-22"></a></span>
<span id="cb26-23"><a href="#cb26-23"></a><span class="co">// isFunctor :: a -&gt; Bool</span></span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="kw">const</span> isFunctor  <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="op">!!</span>x <span class="op">&amp;&amp;</span> <span class="at">isFunction</span>(x[<span class="st">&#39;map&#39;</span>])</span>
<span id="cb26-25"><a href="#cb26-25"></a></span>
<span id="cb26-26"><a href="#cb26-26"></a><span class="co">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b</span></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="kw">const</span> mapFunctor <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="va">m</span>.<span class="at">map</span>(fn)</span></code></pre></div>
<p>That is surprisingly simple, isn’t it? We use our <code>isFunction</code> check from before to test if <code>m</code> has a <code>map</code> property that is a <code>Function</code>, then we call <code>map</code> on <code>m</code> and pass it the callback <code>Function</code> in <code>mapFunctor</code>.</p>
<p>You might be thinking that <code>mapArray</code> and <code>mapFunctor</code> could use the same handler because <code>Array</code>s are <code>Functors</code>, and you are correct; however, because of the extra implementation bits that come back from <code>Array.prototype.map</code>, we’ll keep them separate and only call the callback to <code>Array.prototype.map</code> with the currently iterated item. Here’s the difference:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1"></a><span class="co">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">const</span> mapArray <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="va">m</span>.<span class="at">map</span>(x <span class="kw">=&gt;</span> (<span class="at">fn</span>(x))</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="kw">const</span> mapFunctor <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="va">m</span>.<span class="at">map</span>(fn)</span></code></pre></div>
<p>If you don’t care about this, it’s totally acceptable to not include the <code>Array</code> bits at all and use the <code>Functor</code> <code>map</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> to handle the <code>map</code>ping of <code>Array</code>s, since they’re <code>Functor</code>s.</p>
<p>To test our <code>Functor</code> <code>map</code>ping, we’ll use <a href="https://crocks.dev">crocks</a> to provide us access to an algebraic data type called <a href="https://crocks.dev/docs/crocks/Maybe.html"><code>Maybe</code></a>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1"></a><span class="im">import</span> <span class="op">{</span> compose<span class="op">,</span> option<span class="op">,</span> prop <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;crocks&#39;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="kw">const</span> company <span class="op">=</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>  <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;Pearce Software, LLC&#39;</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>  <span class="dt">locations</span><span class="op">:</span> [</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="st">&#39;Charleston, SC, USA&#39;</span><span class="op">,</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="st">&#39;Auckland, NZ&#39;</span><span class="op">,</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="st">&#39;London, England, UK&#39;</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>  ]</span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="op">}</span></span>
<span id="cb28-11"><a href="#cb28-11"></a></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="at">prop</span>(<span class="st">&#39;foo&#39;</span><span class="op">,</span> company)       <span class="co">// Nothing</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="at">prop</span>(<span class="st">&#39;locations&#39;</span><span class="op">,</span> company) <span class="co">// Just [String]</span></span>
<span id="cb28-14"><a href="#cb28-14"></a></span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="at">option</span>([]<span class="op">,</span> <span class="at">prop</span>(<span class="st">&#39;foo&#39;</span><span class="op">,</span> company))</span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="co">// []</span></span>
<span id="cb28-17"><a href="#cb28-17"></a></span>
<span id="cb28-18"><a href="#cb28-18"></a><span class="at">option</span>([]<span class="op">,</span> <span class="at">prop</span>(<span class="st">&#39;locations&#39;</span><span class="op">,</span> company))</span>
<span id="cb28-19"><a href="#cb28-19"></a><span class="co">// [</span></span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="co">//   &#39;Charleston, SC, USA&#39;,</span></span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="co">//   &#39;Auckland, NZ&#39;,</span></span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="co">//   &#39;London, England, UK&#39;</span></span>
<span id="cb28-23"><a href="#cb28-23"></a><span class="co">// ]</span></span>
<span id="cb28-24"><a href="#cb28-24"></a></span>
<span id="cb28-25"><a href="#cb28-25"></a><span class="kw">const</span> getLocations <span class="op">=</span> <span class="at">compose</span>(<span class="at">option</span>([])<span class="op">,</span> <span class="at">prop</span>(<span class="st">&#39;locations&#39;</span>))</span>
<span id="cb28-26"><a href="#cb28-26"></a><span class="at">getLocations</span>(company)</span>
<span id="cb28-27"><a href="#cb28-27"></a><span class="co">// [</span></span>
<span id="cb28-28"><a href="#cb28-28"></a><span class="co">//   &#39;Charleston, SC, USA&#39;,</span></span>
<span id="cb28-29"><a href="#cb28-29"></a><span class="co">//   &#39;Auckland, NZ&#39;,</span></span>
<span id="cb28-30"><a href="#cb28-30"></a><span class="co">//   &#39;London, England, UK&#39;</span></span>
<span id="cb28-31"><a href="#cb28-31"></a><span class="co">// ]</span></span></code></pre></div>
<p>Pump the breaks! What’s all this <code>Just</code> and <code>Nothing</code> stuff? We’re not going to focus on <code>Maybe</code>s today<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, but the short version is that the <code>locations</code> property <em>may</em> or <em>may not</em> be present in the object, so we encapsulate that uncertainty inside of a <code>Maybe</code> algebraic data type via the <code>prop</code> function, and we provide a default value via the <code>option</code> function that the <code>Maybe</code> can fall back to in the event of not being able to find <code>locations</code>.</p>
<p>Why does this matter? We want to <code>map</code> a <code>Maybe</code>, and the <code>prop</code> function will give us access to one. Let’s see what it looks like:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1"></a><span class="im">import</span> <span class="op">{</span> compose<span class="op">,</span> option<span class="op">,</span> prop <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;crocks&#39;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">const</span> upcase <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="va">x</span>.<span class="at">toUpperCase</span>()</span>
<span id="cb29-4"><a href="#cb29-4"></a></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="kw">const</span> getLocations <span class="op">=</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>  <span class="at">compose</span>(<span class="at">option</span>([])<span class="op">,</span> <span class="at">map</span>(<span class="at">map</span>(upcase))<span class="op">,</span> <span class="at">prop</span>(<span class="st">&#39;locations&#39;</span>))</span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="at">getLocations</span>(<span class="op">{}</span>) <span class="co">// []</span></span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="at">getLocations</span>(company)</span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="co">// [</span></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="co">//   &#39;CHARLESTON, SC, USA&#39;,</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="co">//   &#39;AUCKLAND, NZ&#39;,</span></span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="co">//   &#39;LONDON, ENGLAND, UK&#39;</span></span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="co">// ]</span></span></code></pre></div>
<p>Okay, cool! But why are we <code>map</code>ping twice?</p>
<p>When we work with algebraic data types like <code>Maybe</code>, instead of writing <code>if (dataIsValid) doSomething</code>, the <code>map</code> method on a <code>Maybe</code> gives us access to the value inside the <code>Maybe</code> (our <code>locations</code>), but it does so <em>only if the data is available</em>.</p>
<p>Once we have access to the <code>locations</code>, we then use <code>map</code> again to uppercase each location.</p>
<h2 id="throwing-out-bad-data"><code>throw</code>ing Out Bad Data</h2>
<p>What happens if the arguments passed to <code>map</code> aren’t a <code>Function</code> and a <code>Functor</code>?</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb30-1"><a href="#cb30-1"></a><span class="at">map</span>(<span class="kw">null</span>)([<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])    <span class="co">// TypeError: fn is not a function</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span>)(<span class="kw">null</span>) <span class="co">// undefined</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="at">map</span>(<span class="kw">null</span>)(<span class="kw">null</span>)       <span class="co">// undefined</span></span></code></pre></div>
<p>I think we can provide some more helpful messaging to guide users of our <code>map</code> tool on how to use it correctly.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="at">isFunction</span>(fn)) <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="vs">`map: Please provide a Function for the first argument`</span>)</span>
<span id="cb31-5"><a href="#cb31-5"></a>  <span class="op">}</span></span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a>  <span class="co">// ...our other handlers...</span></span>
<span id="cb31-8"><a href="#cb31-8"></a></span>
<span id="cb31-9"><a href="#cb31-9"></a>  <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="vs">`map: Please provide a Functor or Object for the second argument`</span>)</span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="op">}</span></span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="at">map</span>(<span class="kw">null</span>)([<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>])    <span class="co">// TypeError: map: Please provide a Function for the first argument</span></span>
<span id="cb31-13"><a href="#cb31-13"></a><span class="at">map</span>(x <span class="kw">=&gt;</span> x <span class="op">*</span> <span class="dv">2</span>)(<span class="kw">null</span>) <span class="co">// TypeError: map: Please provide a Functor or Object for the second argument</span></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="at">map</span>(<span class="kw">null</span>)(<span class="kw">null</span>)       <span class="co">// TypeError: map: Please provide a Function for the first argument</span></span></code></pre></div>
<p>Now, when we provide bad arguments, we’re told exactly what we need to do.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Congratulations and thank you for making it to the end! If you want to play around with what we created, check out this CodeSandbox: <a href="https://codesandbox.io/s/bitter-grass-tknwb" class="uri">https://codesandbox.io/s/bitter-grass-tknwb</a>.</p>
<p>Here is our code from today in its entirety:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">const</span> <span class="op">{</span> compose<span class="op">,</span> option<span class="op">,</span> prop <span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;crocks&#39;</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="co">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="kw">const</span> map <span class="op">=</span> fn <span class="kw">=&gt;</span> m <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="at">isFunction</span>(fn)) <span class="op">{</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="vs">`map: Please provide a Function for the first argument`</span>)</span>
<span id="cb32-7"><a href="#cb32-7"></a>  <span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8"></a></span>
<span id="cb32-9"><a href="#cb32-9"></a>  <span class="cf">if</span> (<span class="at">isFunction</span>(m)) <span class="op">{</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="cf">return</span> <span class="at">compose</span>(fn<span class="op">,</span> m)</span>
<span id="cb32-11"><a href="#cb32-11"></a>  <span class="op">}</span></span>
<span id="cb32-12"><a href="#cb32-12"></a></span>
<span id="cb32-13"><a href="#cb32-13"></a>  <span class="cf">if</span> (<span class="at">isArray</span>(m)) <span class="op">{</span></span>
<span id="cb32-14"><a href="#cb32-14"></a>    <span class="cf">return</span> <span class="at">mapArray</span>(fn<span class="op">,</span> m)</span>
<span id="cb32-15"><a href="#cb32-15"></a>  <span class="op">}</span></span>
<span id="cb32-16"><a href="#cb32-16"></a></span>
<span id="cb32-17"><a href="#cb32-17"></a>  <span class="cf">if</span> (<span class="at">isFunctor</span>(m)) <span class="op">{</span></span>
<span id="cb32-18"><a href="#cb32-18"></a>    <span class="cf">return</span> <span class="at">mapFunctor</span>(fn<span class="op">,</span> m)</span>
<span id="cb32-19"><a href="#cb32-19"></a>  <span class="op">}</span></span>
<span id="cb32-20"><a href="#cb32-20"></a></span>
<span id="cb32-21"><a href="#cb32-21"></a>  <span class="cf">if</span> (<span class="at">isObject</span>(m)) <span class="op">{</span></span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="cf">return</span> <span class="at">mapObj</span>(fn<span class="op">,</span> m)</span>
<span id="cb32-23"><a href="#cb32-23"></a>  <span class="op">}</span></span>
<span id="cb32-24"><a href="#cb32-24"></a></span>
<span id="cb32-25"><a href="#cb32-25"></a>  <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="vs">`map: Please provide a Functor or Object for the second argument`</span>)</span>
<span id="cb32-26"><a href="#cb32-26"></a><span class="op">}</span></span>
<span id="cb32-27"><a href="#cb32-27"></a></span>
<span id="cb32-28"><a href="#cb32-28"></a><span class="co">// we&#39;re opting for crocks&#39; compose, instead</span></span>
<span id="cb32-29"><a href="#cb32-29"></a><span class="co">// compose :: ((b -&gt; c), (a -&gt; b)) -&gt; a -&gt; c</span></span>
<span id="cb32-30"><a href="#cb32-30"></a><span class="co">// const compose = (f, g) =&gt; x =&gt; f(g(x))</span></span>
<span id="cb32-31"><a href="#cb32-31"></a></span>
<span id="cb32-32"><a href="#cb32-32"></a><span class="co">// isArray :: a -&gt; Bool</span></span>
<span id="cb32-33"><a href="#cb32-33"></a><span class="kw">const</span> isArray <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="va">Array</span>.<span class="at">isArray</span>(x)</span>
<span id="cb32-34"><a href="#cb32-34"></a></span>
<span id="cb32-35"><a href="#cb32-35"></a><span class="co">// isFunction :: a -&gt; Bool</span></span>
<span id="cb32-36"><a href="#cb32-36"></a><span class="kw">const</span> isFunction <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="kw">typeof</span> x <span class="op">===</span> <span class="st">&#39;function&#39;</span></span>
<span id="cb32-37"><a href="#cb32-37"></a></span>
<span id="cb32-38"><a href="#cb32-38"></a><span class="co">// isFunctor :: a -&gt; Bool</span></span>
<span id="cb32-39"><a href="#cb32-39"></a><span class="kw">const</span> isFunctor  <span class="op">=</span> x <span class="kw">=&gt;</span> <span class="op">!!</span>x <span class="op">&amp;&amp;</span> <span class="at">isFunction</span>(x[<span class="st">&#39;map&#39;</span>])</span>
<span id="cb32-40"><a href="#cb32-40"></a></span>
<span id="cb32-41"><a href="#cb32-41"></a><span class="co">// isObject :: a -&gt; Bool</span></span>
<span id="cb32-42"><a href="#cb32-42"></a><span class="kw">const</span> isObject <span class="op">=</span> x <span class="kw">=&gt;</span></span>
<span id="cb32-43"><a href="#cb32-43"></a>  <span class="op">!!</span>x <span class="op">&amp;&amp;</span> <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(x) <span class="op">===</span> <span class="st">&#39;[object Object]&#39;</span></span>
<span id="cb32-44"><a href="#cb32-44"></a></span>
<span id="cb32-45"><a href="#cb32-45"></a><span class="co">// mapArray :: ((a -&gt; b), Array a) -&gt; Array b</span></span>
<span id="cb32-46"><a href="#cb32-46"></a><span class="kw">const</span> mapArray <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb32-47"><a href="#cb32-47"></a>  <span class="kw">const</span> newArray <span class="op">=</span> []</span>
<span id="cb32-48"><a href="#cb32-48"></a></span>
<span id="cb32-49"><a href="#cb32-49"></a>  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">m</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></span>
<span id="cb32-50"><a href="#cb32-50"></a>    <span class="va">newArray</span>.<span class="at">push</span>(<span class="at">fn</span>(m[i]))</span>
<span id="cb32-51"><a href="#cb32-51"></a>  <span class="op">}</span></span>
<span id="cb32-52"><a href="#cb32-52"></a></span>
<span id="cb32-53"><a href="#cb32-53"></a>  <span class="cf">return</span> newArray</span>
<span id="cb32-54"><a href="#cb32-54"></a><span class="op">}</span></span>
<span id="cb32-55"><a href="#cb32-55"></a><span class="co">// realistically, you should use this mapArray:</span></span>
<span id="cb32-56"><a href="#cb32-56"></a><span class="co">// const mapArray = (fn, m) =&gt; m.map(x =&gt; fn(x))</span></span>
<span id="cb32-57"><a href="#cb32-57"></a></span>
<span id="cb32-58"><a href="#cb32-58"></a><span class="co">// mapObj :: (a -&gt; b) -&gt; { k: a } -&gt; { k: b }</span></span>
<span id="cb32-59"><a href="#cb32-59"></a><span class="kw">const</span> mapObj <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="op">{</span></span>
<span id="cb32-60"><a href="#cb32-60"></a>  <span class="kw">const</span> obj <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb32-61"><a href="#cb32-61"></a></span>
<span id="cb32-62"><a href="#cb32-62"></a>  <span class="cf">for</span> (<span class="kw">const</span> [k<span class="op">,</span> v] <span class="kw">of</span> <span class="va">Object</span>.<span class="at">entries</span>(m)) <span class="op">{</span></span>
<span id="cb32-63"><a href="#cb32-63"></a>    obj[k] <span class="op">=</span> <span class="at">fn</span>(v)</span>
<span id="cb32-64"><a href="#cb32-64"></a>  <span class="op">}</span></span>
<span id="cb32-65"><a href="#cb32-65"></a></span>
<span id="cb32-66"><a href="#cb32-66"></a>  <span class="cf">return</span> obj</span>
<span id="cb32-67"><a href="#cb32-67"></a><span class="op">}</span></span>
<span id="cb32-68"><a href="#cb32-68"></a></span>
<span id="cb32-69"><a href="#cb32-69"></a><span class="co">// mapFunctor :: Functor f =&gt; ((a -&gt; b), f a) -&gt; f b</span></span>
<span id="cb32-70"><a href="#cb32-70"></a><span class="kw">const</span> mapFunctor <span class="op">=</span> (fn<span class="op">,</span> m) <span class="kw">=&gt;</span> <span class="va">m</span>.<span class="at">map</span>(fn)</span></code></pre></div>
<hr />
<p>Thank you for reading! <br /> Robert</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://github.com/hemanth/functional-programming-jargon#algebraic-data-type" class="uri">https://github.com/hemanth/functional-programming-jargon#algebraic-data-type</a>  <a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><code>m</code> for <a href="https://github.com/hemanth/functional-programming-jargon#monoid"><code>Monoid</code></a>  <a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Wondering why the data comes last? Check out <a href="https://youtu.be/m3svKOdZijA">Brian Lonsdorf’s “Hey Underscore, You’re Doing It Wrong!” talk</a>. The tl;dr is that you should arrange your arguments from least likely to change to most likely to change in order to pave the way for partial application and greater code reuse.  <a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://github.com/hemanth/functional-programming-jargon#arity" class="uri">https://github.com/hemanth/functional-programming-jargon#arity</a>  <a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://github.com/hemanth/functional-programming-jargon#functor" class="uri">https://github.com/hemanth/functional-programming-jargon#functor</a>  <a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" class="uri">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray</a>  <a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Check out <a href="https://ramdajs.com/docs/#addIndex">ramda.js’ <code>addIndex</code> function</a> to see a different pattern for working with indices and <code>Array</code>s.  <a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><code>Functor</code> <code>map</code> is also known as <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class"><code>fmap</code></a>.  <a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>If you’re an <a href="https://egghead.io">egghead.io</a> subscriber, <a href="https://twitter.com/avanslaars/">Andy Van Slaars</a> has a great course, <a href="https://egghead.io/courses/safer-javascript-with-the-maybe-type">Safer JavaScript with the Maybe Type</a>, or you can check out <a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class">a Haskell article on The Functor class</a>.  <a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
  </article>
</main>

<footer>
  <section class="subscribe section--padded">
  <div class="layout--constrained">
    <h2 class="subscribe__header">Get notified of new posts</h2>

    <form action="//robertwpearce.us13.list-manage.com/subscribe/post?u=2df44e8960266388bff165fa6&amp;id=ee2f2a3737" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate class="subscribe__form">
      <div style="position: absolute; left: -5000px;" aria-hidden="true">
        <input type="text" name="b_2df44e8960266388bff165fa6_ee2f2a3737" tabindex="-1" value="">
      </div>
      <div class="subscribe__section">
        <input type="email" value="" id="mce-EMAIL" class="subscribe__input" name="EMAIL" placeholder="you@greatemail.com" aria-label="Email Address">
        <input type="submit" value="Subscribe" name="subscribe" class="subscribe__submit">
      </div>
      <small>Note: I will <em>never</em> give out your email nor spam you. Unsubscribe at any time.</small>
    </form>
    <p>
      <small>(or subscribe to the <a href="/atom.xml" class="subscribe__link">atom</a> or <a class="subscribe__link" href="/rss.xml">rss</a> feeds)</small>
    </p>
  </div>
</section>

</footer>

    <script async src="/js/dist/index.js"></script>
  </body>
</html>
