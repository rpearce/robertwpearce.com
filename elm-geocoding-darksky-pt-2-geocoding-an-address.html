<!DOCTYPE html><html lang="en"><head><title>Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address."><meta name="author" content="Robert Pearce"><meta name="keywords" content="elm, elm tutorial, elmlang, elm geocoding, elm darksky, elm weather, elm functional programming"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address"><meta property="og:url" content="https://robertwpearce.com/elm-geocoding-darksky-pt-2-geocoding-an-address.html"><meta property="og:description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address"><meta property="twitter:description" content="In Part 2 we will use Elm & the Google Maps API to geocode an address."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>💾</text></svg>"><link rel="canonical" href="https://robertwpearce.com/elm-geocoding-darksky-pt-2-geocoding-an-address.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>Elm, Geocoding & DarkSky: Pt. 2 – Geocoding an Address</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>In Part 2 we will use Elm & the Google Maps API to geocode an address.</td></tr><tr><th>Shared</th><td>2017-07-30</td></tr></tbody></table></section><section data-area="note"><p>This is part 2 of a multipart series where we will be building a small weather forecast app using <a href="http://elm-lang.org/">Elm</a>, <a href="https://developers.google.com/maps/documentation/geocoding/start">Google’s Geocoding API</a> and the <a href="https://darksky.net/dev/">DarkSky API</a>. Instead of doing everything in one massive post, I’ve broken the steps down into parts of a series. Here is the series plan:</p><ul><li><a href="/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Pt. 1 – Setup Elm &amp; Proxy Servers</a></li><li>Pt. 2 – Geocoding an Address</li><li><a href="/elm-geocoding-and-darksky-pt-3-fetching-the-current-weather.html">Pt. 3 – Fetching the Current Weather</a></li><li><a href="/elm-geocoding-and-darksky-pt-4-extracting-our-elm-code.html">Pt. 4 – Extracting Our Elm Code</a></li></ul><p>If you’d like to code along with this tutorial, check out <a href="/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">part 1</a> first to get set up.</p><p><em>Note: to learn more about the Elm language and syntax, check out the <a href="https://www.elm-tutorial.org/en/">Elm Tutorial</a>, the <a href="https://egghead.io/courses/start-using-elm-to-build-web-applications">EggHead.io Elm course</a>, subscribe to <a href="https://www.dailydrip.com/topics/elm">DailyDrip’s Elm Topic</a>, <a href="http://courses.knowthen.com">James Moore’s Elm Courses</a> or check out <a href="http://exercism.io/languages/elm/about">Elm on exercism.io</a>.</em></p><h2 id="overview">Overview</h2><p>Before we can send a weather forecast request to DarkSky, we need to geocode an address to get its latitude and longitutde. In this post, we’re going to use Elm and our geocoding server from <a href="/elm-geocoding-and-darksky-pt-1-setup-elm-and-proxy-servers.html">Part 1</a> to geocode an address based on a user’s input in a text box.</p><p>Warning: this is a hefty post.</p><h2 id="project-source-code">Project Source Code</h2><p>The project we’re making will be broken into parts here (branches will be named for each part): <a href="https://github.com/rpearce/elm-geocoding-darksky/">https://github.com/rpearce/elm-geocoding-darksky/</a>. Be sure to check out the other branches to see the other parts as they become available.</p><p>The code for this part is located in the <code>pt-2</code> branch: <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2">https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2</a>.</p><h2 id="steps-for-today">Steps for Today</h2><p>What we want to do with our program today is create an HTTP GET request with an address that is input by a user and returns the latitude and longitude. These steps will get us there:</p><ol><li>Defining our primary data model</li><li>Understanding Google’s geocode response data</li><li>Modeling the geocode response data</li><li>Creating JSON decoders</li><li>Building our view and listening for events</li><li>Adding message types</li><li>Writing our update function</li><li>Making our request</li><li>Handling the geocode response</li><li>Final wiring up with the main function &amp; defaults</li></ol><h2 id="1-defining-our-primary-data-model">1: Defining our primary data model</h2><p>At the top level for our app, we only care about an address and latitude and longitude coordinates. While the address’ type will definitely be <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/String">String</a>, we can choose between a <a href="https://guide.elm-lang.org/core_language.html#records">record</a> or <a href="https://guide.elm-lang.org/core_language.html#tuples">tuple</a> to house our coordinates; however, each of these values must be a <code>Float</code> type, as coordinates come in decimal format. For no particular reason, we’re going to use a tuple.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">Model</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">address</span> <span class="pl-nf">:</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">,</span> <span class="pl-nv">coords</span> <span class="pl-nf">:</span> <span class="pl-kt">Coords</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">Coords</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">(</span> <span class="pl-kt">Float</span><span class="pl-p">,</span> <span class="pl-kt">Float</span> <span class="pl-p">)</span></span></span></code></pre><p>I like to keep my models/type aliases fairly clean and primed for re-use in type definitions, so I created a separate type alias, <code>Coords</code>, to represent <code>( Float, Float )</code>.</p><h2 id="2-understanding-googles-geocode-response-data">2: Understanding Google’s geocode response data</h2><p>Let’s take a look at what a geocoding request’s response data for <code>Auckland</code> looks like so we can understand what we’re working with.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s2">"results"</span><span class="pl-o">:</span> <span class="pl-p">[</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-s2">"geometry"</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-s2">"location"</span><span class="pl-o">:</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">          <span class="pl-s2">"lat"</span><span class="pl-o">:</span> <span class="pl-o">-</span><span class="pl-mf">36.8484597</span><span class="pl-p">,</span>
</span></span><span class="pl-line"><span class="pl-cl">          <span class="pl-s2">"lng"</span><span class="pl-o">:</span> <span class="pl-mf">174.7633315</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-c1">// ...
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>      <span class="pl-p">},</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-c1">// ...
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">],</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-s2">"status"</span><span class="pl-o">:</span> <span class="pl-s2">"OK"</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span></span></span></code></pre><p>If you’ve set up your <a href="/node-js-geocoding-proxy-with-paperplane.html">geocoding proxy</a>, you can see these same results by running this command:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl">λ curl localhost:5050/geocode/Auckland</span></span></code></pre><p>We can see here that we get back a <code>status</code> string and a <code>results</code> list where one of the results contains a <code>geometry</code> object, and inside of that, we find <code>location</code> and finally, our quarry: <code>lat</code> and <code>lng</code>. If we were searching for this with JavaScript, we might find this data like so:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">response</span><span class="pl-p">.</span><span class="pl-nx">results</span><span class="pl-p">.</span><span class="pl-nx">find</span><span class="pl-p">(</span><span class="pl-nx">x</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">x</span><span class="pl-p">[</span><span class="pl-s1">'geometry'</span><span class="pl-p">]).</span><span class="pl-nx">geometry</span><span class="pl-p">.</span><span class="pl-nx">location</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// { lat: -36.8484597, lng: 174.7633315 }
</span></span></span></code></pre><p>What would happen in vanilla JavaScript if there were no results, or those object keys didn’t exist? Elm steps up to help us solve for the unexpected.</p><h2 id="3-modeling-the-geocode-response-data">3: Modeling the geocode response data</h2><p>Based on the geocoding response, let’s list out what we’re looking at:</p><ul><li>a string, <code>status</code></li><li>a list of <code>results</code></li><li>each result has a <code>geometry</code> object</li><li>a <code>geometry</code> object has a <code>location</code> object</li><li>a <code>location</code> object has both <code>lat</code> and <code>lng</code> properties, each of which use decimal points</li></ul><p>Since we’re going to need decode these bits of data and reuse the types a few times, let’s create type aliases for each of these concepts (prefixed with <code>Geo</code>):</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">GeoModel</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">status</span> <span class="pl-nf">:</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">,</span> <span class="pl-nv">results</span> <span class="pl-nf">:</span> <span class="pl-kt">List</span> <span class="pl-kt">GeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">GeoResult</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">geometry</span> <span class="pl-nf">:</span> <span class="pl-kt">GeoGeometry</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">GeoGeometry</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">location</span> <span class="pl-nf">:</span> <span class="pl-kt">GeoLocation</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kr">alias</span> <span class="pl-kt">GeoLocation</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">lat</span> <span class="pl-nf">:</span> <span class="pl-kt">Float</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">,</span> <span class="pl-nv">lng</span> <span class="pl-nf">:</span> <span class="pl-kt">Float</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span></span></span></code></pre><p>If you’re not sure what <code>type alias</code> means, read more about <a href="https://guide.elm-lang.org/types/type_aliases.html">type aliases in <em>An Introduction to Elm</em></a>.</p><h2 id="4-creating-json-decoders">4: Creating JSON decoders</h2><p>There are a number of ways to decode JSON in Elm, and <a href="https://www.brianthicks.com">Brian Hicks</a> has <a href="https://www.brianthicks.com/post/2016/08/22/decoding-large-json-objects-a-summary/">written about this</a> (and has a <a href="https://www.brianthicks.com/json-survival-kit/">short book on decoding JSON</a>), and so have many others, such as <a href="https://robots.thoughtbot.com/decoding-json-structures-with-elm">Thoughtbot</a>. Today, we’re going to be working with <a href="https://github.com/NoRedInk/elm-decode-pipeline">NoRedInk’s elm-decode-pipeline</a>.</p><p>First, we install the package into our project:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl">λ elm package install NoRedInk/elm-decode-pipeline</span></span></code></pre><p>In our <code>Main.elm</code> file, we can import what we’ll need from Elm’s <a href>core Json-Decode module</a> as well as the package we’ve just installed.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- Importing from elm core.</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- We know from our type aliases that all we're working</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- with right now are floats, lists and strings.</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Json.Decode</span> <span class="pl-nv">exposing</span> <span class="pl-p">(</span><span class="pl-nv">float</span><span class="pl-p">,</span> <span class="pl-nv">list</span><span class="pl-p">,</span> <span class="pl-nv">string</span><span class="pl-p">,</span> <span class="pl-kt">Decoder</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- importing from elm-decode-pipeline</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Json.Decode.Pipeline</span> <span class="pl-nv">exposing</span> <span class="pl-p">(</span><span class="pl-nv">decode</span><span class="pl-p">,</span> <span class="pl-nv">required</span><span class="pl-p">)</span></span></span></code></pre><p>Now we can write our decoders!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeo</span> <span class="pl-nf">:</span> <span class="pl-kt">Decoder</span> <span class="pl-kt">GeoModel</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeo</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nv">decode</span> <span class="pl-kt">GeoModel</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"status"</span> <span class="pl-nv">string</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"results"</span> <span class="pl-p">(</span><span class="pl-nv">list</span> <span class="pl-nv">decodeGeoResult</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoResult</span> <span class="pl-nf">:</span> <span class="pl-kt">Decoder</span> <span class="pl-kt">GeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoResult</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nv">decode</span> <span class="pl-kt">GeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"geometry"</span> <span class="pl-nv">decodeGeoGeometry</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoGeometry</span> <span class="pl-nf">:</span> <span class="pl-kt">Decoder</span> <span class="pl-kt">GeoGeometry</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoGeometry</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nv">decode</span> <span class="pl-kt">GeoGeometry</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"location"</span> <span class="pl-nv">decodeGeoLocation</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoLocation</span> <span class="pl-nf">:</span> <span class="pl-kt">Decoder</span> <span class="pl-kt">GeoLocation</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeGeoLocation</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nv">decode</span> <span class="pl-kt">GeoLocation</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"lat"</span> <span class="pl-nv">float</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-nv">required</span> <span class="pl-s">"lng"</span> <span class="pl-nv">float</span></span></span></code></pre><p>Here we declare that we’d like to decode the JSON string according to our type aliases, such as <code>GeoModel</code>, and we expect certain keys to have certain value types. In the case of <code>status</code>, that’s just a string; however, with <code>results</code>, we actually have a list of some other type of data, <code>GeoResult</code>, and so we create another decoder function down the line until we dig deep enough to find what we’re looking for. In short, we’re opting for functions and type-checking over deep nesting.</p><p>Why does this feel so verbose? Personally, I’m not yet comfortable using <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#at">Json.Decode.at</a>, which might look like</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">decodeString</span> <span class="pl-p">(</span><span class="pl-nv">at</span> <span class="pl-p">[</span> <span class="pl-s">"results"</span> <span class="pl-p">]</span> <span class="pl-p">(</span><span class="pl-nv">list</span> <span class="pl-p">(</span><span class="pl-nv">at</span> <span class="pl-p">[</span> <span class="pl-s">"geometry"</span><span class="pl-p">,</span> <span class="pl-s">"location"</span> <span class="pl-p">]</span> <span class="pl-p">(</span><span class="pl-nv">keyValuePairs</span> <span class="pl-nv">float</span><span class="pl-p">))))</span> <span class="pl-nv">jsonString</span></span></span></code></pre><p>But with the former approach, we get to be <em>very</em> specific with exactly what we are expecting our data to be shaped like while maintaining clarity.</p><h2 id="5-building-our-view-and-listening-for-events">5: Building our view and listening for events</h2><p>It’s time to add our <code>view</code> function. All we’re going for today is</p><ul><li>a text input that will keep track of the <code>address</code> by responding to the <code>onInput</code> event</li><li>a form around the input that listens for the <code>onSubmit</code> event</li><li>a paragraph to display the coordinates; for example, <code>Coords: (123, 456)</code></li></ul><p>As usual, let’s download <a href="https://github.com/elm-lang/html">the official elm-lang/html package</a>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl">λ elm package install elm-lang/html</span></span></code></pre><p>Then let’s import what we need from it:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Html</span> <span class="pl-nv">exposing</span> <span class="pl-p">(</span><span class="pl-kt">Html</span><span class="pl-p">,</span> <span class="pl-nv">div</span><span class="pl-p">,</span> <span class="pl-nv">form</span><span class="pl-p">,</span> <span class="pl-nv">input</span><span class="pl-p">,</span> <span class="pl-nv">p</span><span class="pl-p">,</span> <span class="pl-nv">text</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Html.Attributes</span> <span class="pl-nv">exposing</span> <span class="pl-p">(</span><span class="pl-nv">placeholder</span><span class="pl-p">,</span> <span class="pl-nv">type_</span><span class="pl-p">,</span> <span class="pl-nv">value</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Html.Events</span> <span class="pl-nv">exposing</span> <span class="pl-p">(</span><span class="pl-nv">onInput</span><span class="pl-p">,</span> <span class="pl-nv">onSubmit</span><span class="pl-p">)</span></span></span></code></pre><p>Each import is a function that we can use to help generate HTML5 elements which Elm then works with behind the scenes.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">view</span> <span class="pl-nf">:</span> <span class="pl-kt">Model</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">Html</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">view</span> <span class="pl-nv">model</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nv">div</span> <span class="pl-p">[]</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">[</span> <span class="pl-nv">form</span> <span class="pl-p">[</span> <span class="pl-nv">onSubmit</span> <span class="pl-kt">SendAddress</span> <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">[</span> <span class="pl-nv">input</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">[</span> <span class="pl-nv">type_</span> <span class="pl-s">"text"</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">,</span> <span class="pl-nv">placeholder</span> <span class="pl-s">"City"</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">,</span> <span class="pl-nv">value</span> <span class="pl-nv">model</span><span class="pl-nf">.</span><span class="pl-nv">address</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">,</span> <span class="pl-nv">onInput</span> <span class="pl-kt">UpdateAddress</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">[]</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">,</span> <span class="pl-nv">p</span> <span class="pl-p">[]</span> <span class="pl-p">[</span> <span class="pl-nv">text</span> <span class="pl-p">(</span><span class="pl-s">"Coords: "</span> <span class="pl-nf">++</span> <span class="pl-p">(</span><span class="pl-nv">toString</span> <span class="pl-nv">model</span><span class="pl-nf">.</span><span class="pl-nv">coords</span><span class="pl-p">))</span> <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">]</span></span></span></code></pre><p>Our <code>view</code> function takes in our model and uses Elm functions to then render output. Great! But what are <code>SendAdress</code> and <code>UpdateAddress</code>? If you’re coming from JavaScript, you might think these are callbacks or higher-order functions, but they are not. They are custom message types (that we’ll define momentarily) that will be used in our <code>update</code> function to determine what flow our application should take next.</p><h2 id="6-adding-message-types">6: Adding message types</h2><p>Thus far, we know of two message types, <code>Update</code> and <code>SendAddress</code>, but how do we define them? If you look at our <code>view</code> function again, you’ll see the return type <code>Html Msg</code>. The second part of this will be the <code>type</code> that we create, and our custom message types will be a part of that! This is something called a <a href="https://guide.elm-lang.org/types/union_types.html">union type</a>.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">=</span> <span class="pl-kt">UpdateAddress</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">|</span> <span class="pl-kt">SendAddress</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">|</span> <span class="pl-kt">NoOp</span></span></span></code></pre><p>We will be adding more to this shortly, but this is all we have come across thus far.</p><h2 id="7-writing-our-update-function">7: Writing our update function</h2><p>Staying consistent with <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, we’ll define our <code>update</code> function in order to update our data and fire off any commands that need happen. If you’re familiar with Redux, this is where the idea for a “reducer” came from.</p><p>This is tough to do in a blog post, so please be patient, and we’ll walk through this:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">update</span> <span class="pl-nf">:</span> <span class="pl-kt">Msg</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">Model</span> <span class="pl-nf">-&gt;</span> <span class="pl-p">(</span> <span class="pl-kt">Model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span> <span class="pl-kt">Msg</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">update</span> <span class="pl-nv">msg</span> <span class="pl-nv">model</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kr">case</span> <span class="pl-nv">msg</span> <span class="pl-kr">of</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">UpdateAddress</span> <span class="pl-nv">text</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-p">{</span> <span class="pl-nv">model</span> <span class="pl-nf">|</span> <span class="pl-nv">address</span> <span class="pl-nf">=</span> <span class="pl-nv">text</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">SendAddress</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-nv">model</span><span class="pl-p">,</span> <span class="pl-nv">sendAddress</span> <span class="pl-nv">model</span><span class="pl-nf">.</span><span class="pl-nv">address</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-c1">-- more code here shortly...</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nv">_</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-nv">model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span> <span class="pl-p">)</span></span></span></code></pre><p>Let’s walk through this step-by-step:</p><ul><li>if the message type is <code>UpdateAddress</code>, then <ol><li>we’re expecting a <code>string</code> (defined in our union type)</li><li>we’ll call the argument <code>text</code></li><li>we’ll then return a tuple of our updated model and a <code>Cmd</code> to essentially do nothing else (it’ll pass through the union type and settle on the <code>NoOp</code>)</li></ol></li><li>if the message type is <code>SendAddress</code>, then <ol><li>we’ll accept <em>no</em> parameters</li><li>we’ll return a tuple of our model <em>with no changes</em> and a command that we haven’t defined yet. This is where we call the function that will actually go and get our geocode data!</li></ol></li></ul><h2 id="8-making-our-request">8: Making our request</h2><p>In order to build and send HTTP requests, we’ll need to make sure we download the <a href="https://github.com/elm-lang/http">elm-lang/http</a> package:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl">λ elm package install elm-lang/http</span></span></code></pre><p>and import it:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kn">import </span><span class="pl-nc">Http</span></span></span></code></pre><p>In our <code>update</code> function, we referenced a function named <code>sendAddress</code> and passed it our model’s address as a parameter. This function should accept a string, initiate our HTTP request and return a command with a message.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">sendAddress</span> <span class="pl-nf">:</span> <span class="pl-kt">String</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">Cmd</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">sendAddress</span> <span class="pl-nv">address</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">Http</span><span class="pl-nf">.</span><span class="pl-nv">get</span> <span class="pl-p">(</span><span class="pl-nv">geocodingUrl</span> <span class="pl-nv">address</span><span class="pl-p">)</span> <span class="pl-nv">decodeGeo</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nf">|&gt;</span> <span class="pl-kt">Http</span><span class="pl-nf">.</span><span class="pl-nv">send</span> <span class="pl-kt">ReceiveGeocoding</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">geocodingUrl</span> <span class="pl-nf">:</span> <span class="pl-kt">String</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">geocodingUrl</span> <span class="pl-nv">address</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-s">"http://localhost:5050/geocode/"</span> <span class="pl-nf">++</span> <span class="pl-nv">address</span></span></span></code></pre><p>Our <code>sendAddress</code> function does this:</p><ol><li>it builds a GET request using two arguments: a URL (derived from <code>geocodingUrl</code>) and our <code>decodeGeo</code> decoder function</li><li>it then pipes the return value from <code>Http.get</code> to be the second argument for <code>Http.send</code></li></ol><p>Note that <code>Http.send</code>’s first argument is a <code>Msg</code> that we haven’t defined yet, so let’s add that to our <code>Msg</code> union type:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">type</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">=</span> <span class="pl-kt">UpdateAddress</span> <span class="pl-kt">String</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">|</span> <span class="pl-kt">SendAddress</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">|</span> <span class="pl-kt">ReceiveGeocoding</span> <span class="pl-p">(</span><span class="pl-kt">Result</span> <span class="pl-kt">Http</span><span class="pl-nf">.</span><span class="pl-kt">Error</span> <span class="pl-kt">GeoModel</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nf">|</span> <span class="pl-kt">NoOp</span></span></span></code></pre><p>Basically, we’ll either get back an HTTP error or a data structure in the shape of our <code>GeoModel</code>.</p><h2 id="9-handling-the-geocode-response">9: Handling the geocode response</h2><p>Finally, we now need to handle the successful and erroneous responses in our update function:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nv">update</span> <span class="pl-nf">:</span> <span class="pl-kt">Msg</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">Model</span> <span class="pl-nf">-&gt;</span> <span class="pl-p">(</span> <span class="pl-kt">Model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span> <span class="pl-kt">Msg</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">update</span> <span class="pl-nv">msg</span> <span class="pl-nv">model</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kr">case</span> <span class="pl-nv">msg</span> <span class="pl-kr">of</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">UpdateAddress</span> <span class="pl-nv">text</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-p">{</span> <span class="pl-nv">model</span> <span class="pl-nf">|</span> <span class="pl-nv">address</span> <span class="pl-nf">=</span> <span class="pl-nv">text</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">SendAddress</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-nv">model</span><span class="pl-p">,</span> <span class="pl-nv">sendAddress</span> <span class="pl-nv">model</span><span class="pl-nf">.</span><span class="pl-nv">address</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">ReceiveGeocoding</span> <span class="pl-p">(</span><span class="pl-kt">Ok</span> <span class="pl-p">{</span> <span class="pl-nv">results</span><span class="pl-p">,</span> <span class="pl-nv">status</span> <span class="pl-p">})</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-kr">let</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-nv">result</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">                    <span class="pl-kr">case</span> <span class="pl-nv">status</span> <span class="pl-kr">of</span>
</span></span><span class="pl-line"><span class="pl-cl">                        <span class="pl-s">"OK"</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">                            <span class="pl-nv">results</span>
</span></span><span class="pl-line"><span class="pl-cl">                                <span class="pl-nf">|&gt;</span> <span class="pl-kt">List</span><span class="pl-nf">.</span><span class="pl-nv">head</span>
</span></span><span class="pl-line"><span class="pl-cl">                                <span class="pl-nf">|&gt;</span> <span class="pl-kt">Maybe</span><span class="pl-nf">.</span><span class="pl-nv">withDefault</span> <span class="pl-nv">initialGeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">                        <span class="pl-nv">_</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">                            <span class="pl-nv">initialGeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-nv">location</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">                    <span class="pl-nv">result</span><span class="pl-nf">.</span><span class="pl-nv">geometry</span><span class="pl-nf">.</span><span class="pl-nv">location</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-nv">newModel</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">                    <span class="pl-p">{</span> <span class="pl-nv">model</span> <span class="pl-nf">|</span> <span class="pl-nv">coords</span> <span class="pl-nf">=</span> <span class="pl-p">(</span> <span class="pl-nv">location</span><span class="pl-nf">.</span><span class="pl-nv">lat</span><span class="pl-p">,</span> <span class="pl-nv">location</span><span class="pl-nf">.</span><span class="pl-nv">lng</span> <span class="pl-p">)</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-kr">in</span>
</span></span><span class="pl-line"><span class="pl-cl">                <span class="pl-p">(</span> <span class="pl-nv">newModel</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-kt">ReceiveGeocoding</span> <span class="pl-p">(</span><span class="pl-kt">Err</span> <span class="pl-nv">_</span><span class="pl-p">)</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-nv">model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-nv">_</span> <span class="pl-nf">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">(</span> <span class="pl-nv">model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- This should go with other `init`s</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- but is placed here for relevance</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">initialGeoResult</span> <span class="pl-nf">:</span> <span class="pl-kt">GeoResult</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">initialGeoResult</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">geometry</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">{</span> <span class="pl-nv">location</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">{</span> <span class="pl-nv">lat</span> <span class="pl-nf">=</span> <span class="pl-mi">0</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">,</span> <span class="pl-nv">lng</span> <span class="pl-nf">=</span> <span class="pl-mi">0</span>
</span></span><span class="pl-line"><span class="pl-cl">            <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span></span></span></code></pre><p>Instead of having success/error logic inside one <code>ReceiveGeocoding</code> case match, we use Elm’s pattern matching to allow us to match on the message and <code>Ok</code> or <code>Err</code> <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Result">results</a>.</p><p>Again, let’s do this step-by-step:</p><ul><li><code>ReceiveGeocoding</code> is <code>OK</code><ol><li>we destructure the response into <code>results</code> and <code>status</code> variables</li><li>we check the value of <code>status</code> from the response to make sure all is well</li><li>if status is <code>"OK"</code>, we try to get the first item in the <code>results</code> list and fallback to <code>initialGeoResult</code> if there are no results (I love Elm for enforcing this)</li><li>if status is <em>not</em> <code>"OK"</code>, we fall back to the <code>initialGeoResult</code></li><li>we then access the <code>location</code> record, build an updated model record, and return it</li></ol></li><li><code>ReceiveGeocoding</code> is <code>Err</code><ol><li>we simply return the model</li></ol></li></ul><h2 id="10-final-wiring-up-with-the-main-function--defaults">10: Final wiring up with the main function &amp; defaults</h2><p>Now that we’re through the core of the application’s contents, we can wire up the remaining bits and get it to compile:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- Define our HTML program</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">main </span><span class="pl-nf">:</span> <span class="pl-kt">Program</span> <span class="pl-kt">Never</span> <span class="pl-kt">Model</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">main </span><span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">Html</span><span class="pl-nf">.</span><span class="pl-nv">program</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">{</span> <span class="pl-nv">init</span> <span class="pl-nf">=</span> <span class="pl-nv">init</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">,</span> <span class="pl-nv">view</span> <span class="pl-nf">=</span> <span class="pl-nv">view</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">,</span> <span class="pl-nv">update</span> <span class="pl-nf">=</span> <span class="pl-nv">update</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">,</span> <span class="pl-nv">subscriptions</span> <span class="pl-nf">=</span> <span class="pl-nv">subscriptions</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- Here is our initial model</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">init</span> <span class="pl-nf">:</span> <span class="pl-p">(</span> <span class="pl-kt">Model</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span> <span class="pl-kt">Msg</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">init</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">(</span> <span class="pl-nv">initialModel</span><span class="pl-p">,</span> <span class="pl-kt">Cmd</span><span class="pl-nf">.</span><span class="pl-nv">none</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">initialModel</span> <span class="pl-nf">:</span> <span class="pl-kt">Model</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">initialModel</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">{</span> <span class="pl-nv">address</span> <span class="pl-nf">=</span> <span class="pl-s">""</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">,</span> <span class="pl-nv">coords</span> <span class="pl-nf">=</span> <span class="pl-p">(</span> <span class="pl-mi">0</span><span class="pl-p">,</span> <span class="pl-mi">0</span> <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- We're not using any subscriptions,</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">-- so we'll define none</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">subscriptions</span> <span class="pl-nf">:</span> <span class="pl-kt">Model</span> <span class="pl-nf">-&gt;</span> <span class="pl-kt">Sub</span> <span class="pl-kt">Msg</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nv">subscriptions</span> <span class="pl-nv">model</span> <span class="pl-nf">=</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-kt">Sub</span><span class="pl-nf">.</span><span class="pl-nv">none</span></span></span></code></pre><p>Remember that you can look at the <a href="https://github.com/rpearce/elm-geocoding-darksky/tree/pt-2">source code for this part</a> as a guide.</p><h2 id="wrapping-up">Wrapping Up</h2><p>This has been a massive post on simply fetching geocode data from an API. I’ve found it’s difficult to write posts on Elm in little bits, for you have to have everything in the right place and defined before it’ll work. Subsequent posts in this series will be shorter, as we’ll have already done the heavy-lifting.</p><p>Until next time, <br> Robert</p></section></main><footer><span aria-hidden="true" class="heart">♥</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">♥</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>