<!DOCTYPE html><html lang="en"><head><title>Simple Variadic Behavior</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Beginner-friendly introduction to variadic behavior."><meta name="author" content="Robert Pearce"><meta name="keywords" content="javascript, javascript tutorial, variadic behavior, function arguments, variable arguments, function parameters"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="Simple Variadic Behavior"><meta property="og:url" content="https://robertwpearce.com/simple-variadic-behavior.html"><meta property="og:description" content="Beginner-friendly introduction to variadic behavior."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="Simple Variadic Behavior"><meta property="twitter:description" content="Beginner-friendly introduction to variadic behavior."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ’¾</text></svg>"><link rel="canonical" href="https://robertwpearce.com/simple-variadic-behavior.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>Simple Variadic Behavior</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>Beginner-friendly introduction to variadic behavior.</td></tr><tr><th>Shared</th><td>2015-10-13</td></tr></tbody></table></section><section data-area="note"><p style="text-decoration:line-through;"> Recently, I have started working on my own static site generator, <a href="https://github.com/rpearce/react-static">react-static</a>, to accomodate my markdown blog posting & static site needs. Another benefit is that I get to work on my Node.js and ES2015+ JavaScript skills. While I am reinventing the wheel on some levels, it is good practice. </p><p><strong>Update</strong>: I made a library, <a href="https://www.npmjs.com/package/parse-md">parse-md</a>, out of some of this behavior in order to address the need of parsing metadata from markdown files.</p><p>My latest problem to solve was how, once I had a <code>.md</code> (Markdown) fileâ€™s contents, to go about parsing out the blog postâ€™s metadata (see below: the key/value pairs between the two <code>---</code>s).</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl">---
</span></span><span class="pl-line"><span class="pl-cl">title: This is a test
</span></span><span class="pl-line"><span class="pl-cl">description: Once upon a time, there was a test...
</span></span><span class="pl-line"><span class="pl-cl">---
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-gh"># Title of my great post
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-gh"></span>Lorem ipsum dolor...
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-gu">## Some heading
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-gu"></span>Bacon ipsum...</span></span></code></pre><p>Once I <code>split</code> this file based on newlines, I needed a way of finding the indices of the metadata boundary, <code>---</code>, so that I could <code>splice</code> the array in to two pieces and be on my way. My first attempt at getting the indices looked like this:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kd">var</span> <span class="pl-nx">arr</span> <span class="pl-o">=</span> <span class="pl-p">[];</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">forEach</span><span class="pl-p">((</span><span class="pl-nx">line</span><span class="pl-p">,</span> <span class="pl-nx">i</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-sr">/^---/</span><span class="pl-p">.</span><span class="pl-nx">test</span><span class="pl-p">(</span><span class="pl-nx">line</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-nx">arr</span><span class="pl-p">.</span><span class="pl-nx">push</span><span class="pl-p">(</span><span class="pl-nx">i</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">});</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">arr</span><span class="pl-p">;</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">);</span> <span class="pl-c1">// [0, 3]
</span></span></span></code></pre><p>This is a simple solution that any junior dev can do, and it accomplishes the taskâ€¦ but it doesnâ€™t feel right. I am iterating over each item, testing each line and mutating an array variable when a condition is true. While it doesnâ€™t look like much, that is a good bit going on all at once. Instinct tells me that each action could be its own simple method. I also donâ€™t want to use a temporary variable that I mutate. However, this removes <code>forEach</code> from our options, as <code>forEach</code> returns the original array. <code>map()</code> to the rescue! (or so we think).</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">testForBoundary</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">testForBoundary</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">,</span> <span class="pl-nx">i</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-sr">/^---/</span><span class="pl-p">.</span><span class="pl-nx">test</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">i</span><span class="pl-p">;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">);</span> <span class="pl-c1">// [0, undefined, undefined, 3, undefined, undefined, undefined, undefined, undefined, undefined]
</span></span></span></code></pre><p>Crap. Because I only return when the test is true, <code>map</code> doesnâ€™t know what to return, so it returns <code>undefined</code> and moves on. It would be nice if we could clean out these <code>undefined</code>s!</p><h2 id="cleaning-up-our-array">Cleaning Up Our Array</h2><p>How can we achieve the following desired functionality?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">testForBoundary</span><span class="pl-p">).</span><span class="pl-nx">clean</span><span class="pl-p">(</span><span class="pl-kc">undefined</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">);</span> <span class="pl-c1">// [0, 3]
</span></span></span></code></pre><p>Letâ€™s make a function on the <code>prototype</code> of <code>Array</code> called <code>clean</code>:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">clean</span> <span class="pl-o">=</span> <span class="pl-kd">function</span><span class="pl-p">(</span><span class="pl-nx">trash</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">};</span></span></span></code></pre><p>Here, we access <code>Array</code>â€™s <code>prorotype</code> and add our own custom method, <code>clean</code> and pass it one argument. Next, we need to <code>filter</code> out all of the <code>undefined</code>s in our array.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">clean</span> <span class="pl-o">=</span> <span class="pl-kd">function</span><span class="pl-p">(</span><span class="pl-nx">trash</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-k">this</span><span class="pl-p">.</span><span class="pl-nx">filter</span><span class="pl-p">(</span><span class="pl-nx">item</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">item</span> <span class="pl-o">!==</span> <span class="pl-nx">trash</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">};</span></span></span></code></pre><p>But what if we need to clean more than one value out? What if we need to clean <code>null</code>, <code>""</code> and <code>undefined</code>?</p><h2 id="variadic-behavior">Variadic Behavior</h2><p>In JavaScript, <em>variadic behavior</em> is a fancy term applied to functions that can accept and handle any number of arguments, and these are typically accessed within the function via the <code>arguments</code> object, which looks like an <code>Array</code> but is <em>not</em>. For example, this code will give you an error about <code>indexOf</code> not being defined on <code>arguments</code>.</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">clean</span> <span class="pl-o">=</span> <span class="pl-kd">function</span><span class="pl-p">(</span><span class="pl-nx">trash</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-k">this</span><span class="pl-p">.</span><span class="pl-nx">filter</span><span class="pl-p">(</span><span class="pl-nx">item</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">arguments</span><span class="pl-p">.</span><span class="pl-nx">indexOf</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">};</span></span></span></code></pre><p>Drats! <code>arguments</code> is very similar to an array â€” how can we get this to work? <code>slice</code> to the rescue!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">clean</span> <span class="pl-o">=</span> <span class="pl-kd">function</span><span class="pl-p">()</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">args</span> <span class="pl-o">=</span> <span class="pl-p">[].</span><span class="pl-nx">slice</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-nx">arguments</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-k">this</span><span class="pl-p">.</span><span class="pl-nx">filter</span><span class="pl-p">(</span><span class="pl-nx">item</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">args</span><span class="pl-p">.</span><span class="pl-nx">indexOf</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">};</span></span></span></code></pre><p>Without any additional arguments, <code>slice</code> makes a copy of an array and allows us to provide a custom receiver of array-like functionality: <code>arguments</code>. What is returned from the second line above is an array-ized <em>copy</em> of <code>arguments</code>. Now that <code>args</code> is an array of all the arguments that are passed to <code>clean</code>, we can pass as many options as we would like to clean out our array!</p><p>Here is more example usage of such a method:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// Usage
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">arr</span> <span class="pl-o">=</span> <span class="pl-p">[</span><span class="pl-s2">""</span><span class="pl-p">,</span> <span class="pl-kc">undefined</span><span class="pl-p">,</span> <span class="pl-mi">3</span><span class="pl-p">,</span> <span class="pl-s2">"yes"</span><span class="pl-p">,</span> <span class="pl-kc">undefined</span><span class="pl-p">,</span> <span class="pl-kc">undefined</span><span class="pl-p">,</span> <span class="pl-s2">""</span><span class="pl-p">];</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">arr</span><span class="pl-p">.</span><span class="pl-nx">clean</span><span class="pl-p">(</span><span class="pl-kc">undefined</span><span class="pl-p">);</span> <span class="pl-c1">// ["", 3, "yes", ""];
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">arr</span><span class="pl-p">.</span><span class="pl-nx">clean</span><span class="pl-p">(</span><span class="pl-kc">undefined</span><span class="pl-p">,</span> <span class="pl-s2">""</span><span class="pl-p">);</span> <span class="pl-c1">// [3, "yes"];
</span></span></span></code></pre><h2 id="all-together">All Together</h2><p>In attempting to refactor some fairly simple, though multiple-responsibility code, we end up creating a few reusable functions that will benefit us in the future, and we make our code more maintainable, testable and readable in the end. Here it is once we have finished:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">lines</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">map</span><span class="pl-p">(</span><span class="pl-nx">testForBoundary</span><span class="pl-p">).</span><span class="pl-nx">clean</span><span class="pl-p">(</span><span class="pl-kc">undefined</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">testForBoundary</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">,</span> <span class="pl-nx">i</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-sr">/^---/</span><span class="pl-p">.</span><span class="pl-nx">test</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">i</span><span class="pl-p">;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nb">Array</span><span class="pl-p">.</span><span class="pl-nx">prototype</span><span class="pl-p">.</span><span class="pl-nx">clean</span> <span class="pl-o">=</span> <span class="pl-kd">function</span><span class="pl-p">()</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-kr">const</span> <span class="pl-nx">args</span> <span class="pl-o">=</span> <span class="pl-p">[].</span><span class="pl-nx">slice</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-nx">arguments</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-k">this</span><span class="pl-p">.</span><span class="pl-nx">filter</span><span class="pl-p">(</span><span class="pl-nx">item</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">args</span><span class="pl-p">.</span><span class="pl-nx">indexOf</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">)</span> <span class="pl-o">===</span> <span class="pl-o">-</span><span class="pl-mi">1</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">};</span></span></span></code></pre><p>But could this be done <em>even</em> simpler?</p><h2 id="ps-use-reduce-next-time">p.s. Use reduce next time</h2><p>You may have been wondering why we didnâ€™t use <code>reduce</code> like this from the start:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">reduce</span><span class="pl-p">(</span><span class="pl-kd">function</span><span class="pl-p">(</span><span class="pl-nx">mem</span><span class="pl-p">,</span> <span class="pl-nx">item</span><span class="pl-p">,</span> <span class="pl-nx">i</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-sr">/^---/</span><span class="pl-p">.</span><span class="pl-nx">test</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">mem</span><span class="pl-p">.</span><span class="pl-nx">push</span><span class="pl-p">(</span><span class="pl-nx">i</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">mem</span><span class="pl-p">;</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">});</span></span></span></code></pre><p>or, cleaned up a bit,</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">getMetadataIndices</span><span class="pl-p">(</span><span class="pl-nx">mem</span><span class="pl-p">,</span> <span class="pl-nx">item</span><span class="pl-p">,</span> <span class="pl-nx">i</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-sr">/^---/</span><span class="pl-p">.</span><span class="pl-nx">test</span><span class="pl-p">(</span><span class="pl-nx">item</span><span class="pl-p">))</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">mem</span><span class="pl-p">.</span><span class="pl-nx">push</span><span class="pl-p">(</span><span class="pl-nx">i</span><span class="pl-p">);</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-nx">mem</span><span class="pl-p">;</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">lines</span><span class="pl-p">.</span><span class="pl-nx">reduce</span><span class="pl-p">(</span><span class="pl-nx">getMetadataIndices</span><span class="pl-p">,</span> <span class="pl-p">[]);</span></span></span></code></pre><p>Surprise! We totally could have, but since <code>reduce</code> was not our first thought when refactoring, we managed to solve our problem in another way. There are 1000 ways to solve problems, and sometimes you donâ€™t think of the best one first, but you can still make the best with what you have at the time and refactor later.</p></section></main><footer><span aria-hidden="true" class="heart">â™¥</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">â™¥</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>