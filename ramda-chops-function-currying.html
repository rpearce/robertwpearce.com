<!DOCTYPE html><html lang="en"><head><title>Ramda Chops: Function Currying</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="How function currying works under the hood."><meta name="author" content="Robert Pearce"><meta name="keywords" content="ramda, ramda.js, ramdajs, ramda tutorial, ramda curry, crocks curry, function currying, ramda fp"><meta name="google-site-verification" content="QX4bn65yOXBfgnwxlO09yIBc1H8blur-Erx3lmsDVhU"><meta http-equiv="origin-trial" content="Am4BZ0c7GMyB72dgo/Ny2FfIFscXhYMoN+CVe4jduWh24FvsaCwf7kjZzHzfrJXtIilyZVAEKRxOItGLY7lvkAgAAABSeyJvcmlnaW4iOiJodHRwczovL3JvYmVydHdwZWFyY2UuY29tOjQ0MyIsImZlYXR1cmUiOiJQb3J0YWxzIiwiZXhwaXJ5IjoxNjAzNTQ2NDc3fQ=="><meta property="og:site_name" content="Robert Pearce"><meta property="og:title" content="Ramda Chops: Function Currying"><meta property="og:url" content="https://robertwpearce.com/ramda-chops-function-currying.html"><meta property="og:description" content="How function currying works under the hood."><meta property="og:type" content="article"><meta property="twitter:site" content="Robert Pearce"><meta property="twitter:title" content="Ramda Chops: Function Currying"><meta property="twitter:description" content="How function currying works under the hood."><meta property="twitter:creator" content="@RobertWPearce"><link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üíæ</text></svg>"><link rel="canonical" href="https://robertwpearce.com/ramda-chops-function-currying.html"><link rel="alternate" href="./atom.xml" title="Robert Pearce's blog" type="application/atom+xml"><link rel="alternate" href="./rss.xml" title="Robert Pearce's blog" type="application/rss+xml"><link rel="stylesheet" href="./css/base.css"><link rel="stylesheet" href="./css/t-clean.css"><link rel="stylesheet" href="./css/t-clean-note.css"><link rel="stylesheet" href="./css/t-code-dracula.css"><link rel="prefetch" href="./css/t-clean-note.css"></head><body data-theme="clean-night"><script> (() => { window.site = { prefFont: localStorage.getItem('prefFont') || 'monospace', setFont: (family) => { localStorage.setItem('prefFont', family); const rootStyle = document.querySelector(':root').style; rootStyle.setProperty('--type-family-body', family+',monospace'); /* Remove when https://github.com/googlefonts/spacemono/pull/2 is resolved */ if (family === 'Liga Space Mono') { rootStyle.setProperty('font-feature-settings', '"liga" 0'); } else { rootStyle.removeProperty('font-feature-settings'); } return window.site._fetchFont(family); }, prefTheme: localStorage.getItem('prefTheme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'clean-night' : 'clean-day'), setTheme: (name) => { const rootStyle = document.querySelector(':root').style; if (name === 'clean-night') { rootStyle.removeProperty('color-scheme'); } else { rootStyle.setProperty('color-scheme', 'light'); } document.body.setAttribute('data-theme', name); localStorage.setItem('prefTheme', name); }, _fetchFont: (family) => { if (family === 'monospace') { return Promise.resolve(); } const familyNoSpaces = family.replaceAll(' ', ''); const fontz = [ new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Regular.woff2") format("woff2")', { display: 'swap', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Bold.woff2") format("woff2")', { display: 'swap', weight: 700 }), ]; if (family !== 'Fira Code') { fontz.push( new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-Italic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 400 }), new FontFace(family, 'url("./fonts/'+familyNoSpaces+'-BoldItalic.woff2") format("woff2")', { display: 'swap', style: 'italic', weight: 700 }) ); } for (const f of fontz) { document.fonts.add(f); } return Promise.allSettled(fontz).then(results => { results.forEach((res, i) => { if (res.status === 'rejected') { console.error('site failed to load font: ' + fontz[i]?.family ?? 'unknown'); } }); }); } }; window.site.setTheme(window.site.prefTheme); window.site.setFont(window.site.prefFont); })(); </script><header><nav><div class="nav-skip"><a href="#content">Skip to content</a></div><a aria-label="Home" class="nav-home" href="./">~</a><span>/</span></nav><div class="header-extra"><a href="./atom.xml">RSS</a><span aria-hidden="true">&compfn;</span><noscript>(requires JS &rarr;)</noscript><label for="select-theme">Theme</label><select data-select-theme id="select-theme"><option value="clean-day">Clean (Day)</option><option value="clean-night">Clean (Night)</option></select><span aria-hidden="true">&compfn;</span><label for="select-font">Font</label><select data-select-font id="select-font"><option value="monospace">monospace</option><option value="Liga Space Mono">Space Mono</option><option value="Victor Mono">Victor Mono</option><option value="Fira Code">Fira Code</option><option value="JetBrains Mono">JetBrains Mono</option></select></div></header><main id="content"><header data-area="heading"><h1>Ramda Chops: Function Currying</h1></header><section data-area="meta"><h2>Info</h2><table data-type="cols-y"><tbody><tr><th>Summary</th><td>How function currying works under the hood.</td></tr><tr><th>Shared</th><td>2018-01-23</td></tr></tbody></table></section><section data-area="note"><p><em>Thanks to <a href="https://github.com/jsilve">Jillian Silver</a> and <a href="https://twitter.com/evilsoft">@evilsoft</a> for their review of this post.</em></p><p>Functional Programming concepts have been pouring into the JavaScript community for a number of years now, and many of us struggle to keep up. I‚Äôve been lucky enough to be able to work with some mentors and functional tools that have helped me along the way. One of these tools is <a href="http://ramdajs.com">ramda.js</a>, and it was my gateway to the larger Functional Programming world. I hope it will be for you, as well.</p><p>To understand ramda, you first have to understand a concept known as ‚Äúcurrying.‚Äù The ramda website states,</p><blockquote><p>The parameters to Ramda functions are arranged to make it convenient for currying.</p></blockquote><p>There are some function currying articles on the ramda site, such as <a href="http://fr.umio.us/favoring-curry/">Favoring Curry</a> and <a href="https://hughfdjackson.com/javascript/why-curry-helps/">Why Curry Helps</a> by Scott Sauyet, which are great for explaining the benefits and power of currying. Those articles (and many other resources) do great jobs of explaining how to use currying and why, so I‚Äôll briefly touch on those points, but I really want to focus on how it works under the hood and how this funny little concept will completely change the way that you program.</p><hr /><p><em>Other ramda posts:</em></p><ul><li><a href="/ramda-chops-function-composition.html">Ramda Chops: Function Composition</a></li><li><a href="/ramda-chops-safely-accessing-properties.html">Ramda Chops: Safely Accessing Properties</a></li><li><a href="/ramda-chops-map-filter-and-reduce.html">Ramda Chops: Map, Filter &amp; Reduce</a></li></ul><h2 id="rudimentary-currying">Rudimentary Currying</h2><p>Many articles already cover this, so I‚Äôll keep it short.</p><p>Let‚Äôs start with a function that takes two numbers and adds them together:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// add :: (Number, Number) -&gt; Number
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">add</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span></span></span></code></pre><p>As our fake type signature describes, <code>add</code> takes two arguments (essentially, a <a href="https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples#Tuples%3CPaste%3E">tuple</a>) that are both of type <code>Number</code> and returns a value of type <code>Number</code>.</p><p>But if we wanted to create a function that adds <code>10</code> to anything, we could write the following:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// add :: Number -&gt; Number -&gt; Number
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">add</span> <span class="pl-o">=</span> <span class="pl-nx">a</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">b</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// which is the same as
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kd">function</span> <span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-nx">a</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">return</span> <span class="pl-kd">function</span><span class="pl-p">(</span><span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-k">return</span> <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// and then
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// add10 :: Number -&gt; Number
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">add10</span> <span class="pl-o">=</span> <span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">10</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">add10</span> <span class="pl-c1">// =&gt; Function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add10</span><span class="pl-p">(</span><span class="pl-mi">4</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 14
</span></span></span></code></pre><p>Note the change in type signature: we now have singular arguments that are accepted at a time instead of the tuple style. When we provide the first argument, we are then returned a function that will sit and wait until all the functions are applied before giving us a value. This method can be useful in many situations, but consider the following:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">10</span><span class="pl-p">)(</span><span class="pl-mi">4</span><span class="pl-p">)</span></span></span></code></pre><p>That feels awkward, right? Fear not! There is a way.</p><h2 id="the-curry-function">The <code>curry</code> Function</h2><p>Ramda provides us a function named <code>curry</code> that will take what might be considered a ‚Äúnormal‚Äù JavaScript function definition with multiple parameters and turn it into a function that will keep returning a function until all of its parameters have been supplied. Check it out!</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">import</span> <span class="pl-nx">curry</span> <span class="pl-nx">from</span> <span class="pl-s1">'ramda/src/curry'</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">oldAdd</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">add</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">(</span><span class="pl-nx">oldAdd</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">10</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; Function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">10</span><span class="pl-p">)(</span><span class="pl-mi">4</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 14
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">10</span><span class="pl-p">,</span> <span class="pl-mi">4</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 14
</span></span></span></code></pre><p>Or if you want to have <code>curry</code> baked in to your original <code>add</code> function:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// add :: Number -&gt; Number -&gt; Number
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">add</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">((</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-o">-&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">)</span></span></span></code></pre><p>The magical <code>curry</code> function doesn‚Äôt care when you provide arguments or how you do so ‚Äì it will just keep returning you partially applied functions until all arguments have been applied, at which point it will give you back a value.</p><h2 id="cool-now-how-does-curry-work">Cool‚Ä¶ Now How Does <code>curry</code> Work?</h2><p>This might seem blasphemous, but to understand how <code>curry</code> works under the hood, we‚Äôre going to dive into a different library‚Äôs implementation of it: <a href="https://github.com/evilsoft/crocks">crocks</a> by <a href="https://twitter.com/evilsoft">@evilsoft</a>. (Crocks is similar to ramda but dives more into abstract data types (ADTs) and is more towards the deeper end of the Functional Programming pool.) I think crocks‚Äô implementation is excellent, and 99% of it being in one file makes for a great teaching tool.</p><p>If you want to jump ahead, here is a link to crocks‚Äô <code>curry</code> function: <a href="https://github.com/evilsoft/crocks/blob/master/src/core/curry.js">https://github.com/evilsoft/crocks/blob/master/src/core/curry.js</a></p><p>Where do we start with understanding this next-level JavaScript? Always start with the types, as they can tell a story.</p><h3 id="reading-currys-story">Reading <code>curry</code>‚Äôs Story</h3><p>What does this tell us?</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// curry :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d
</span></span></span></code></pre><ol><li><code>((a, b, c) -&gt; d)</code> tells us that it accepts a function that has <em>n</em> parameters of any type and returns a value of any type</li><li><code>-&gt; a -&gt; b -&gt; c</code> tells us that it then accepts each parameter ‚Äì but only 1 at a time!</li><li><code>-&gt; d</code> tells us that it ultimately returns the value as specified in the function</li></ol><p>Sounds simple, right? Easier said than done!</p><h3 id="what-we-need-to-do">What we need to do</h3><ol><li>we need to first accept a function (the one to be curried)</li><li>we need to then accept <a href="/simple-variadic-behavior.html">any number of arguments (variadic behavior)</a></li><li>when this happens, we need to either</li></ol><ul><li>return a value (when all arguments have been applied)</li><li>return a function that accepts the remaining arguments and repeat this condition</li></ul><h3 id="breaking-down-curry">Breaking Down Curry</h3><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// curry :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// 1. we accept a function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">curry</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// 2. we return a function taking any `n` arguments
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-k">return</span> <span class="pl-p">(...</span><span class="pl-nx">xs</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-c1">// make sure we have a populated list to work with;
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// `undefined` is the value for the Unit type in
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// crocks and calling our function must utilize some
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// sort of value.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-kr">const</span> <span class="pl-nx">args</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-nx">xs</span><span class="pl-p">.</span><span class="pl-nx">length</span> <span class="pl-o">?</span> <span class="pl-nx">xs</span> <span class="pl-o">:</span> <span class="pl-p">[</span> <span class="pl-kc">undefined</span> <span class="pl-p">]</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-c1">// if the number of args sent are
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// less than that required, then
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// don't do more work; go ahead and
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// return a new version of our function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// that is still waiting for more
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// arguments to be applied.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-nx">args</span><span class="pl-p">.</span><span class="pl-nx">length</span> <span class="pl-o">&lt;</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">length</span><span class="pl-p">)</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-c1">// way of safely creating a new function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>      <span class="pl-c1">// and binding arguments to it without
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>      <span class="pl-c1">// calling it.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>      <span class="pl-k">return</span> <span class="pl-nx">curry</span><span class="pl-p">(</span><span class="pl-nb">Function</span><span class="pl-p">.</span><span class="pl-nx">bind</span><span class="pl-p">.</span><span class="pl-nx">apply</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-p">[</span> <span class="pl-kc">null</span> <span class="pl-p">].</span><span class="pl-nx">concat</span><span class="pl-p">(</span><span class="pl-nx">args</span><span class="pl-p">)))</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-c1">// if we've provided all arguments,
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// then let's apply them and give
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// back the result.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// otherwise, let's do some work
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// and see if, based on the number
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// of arguments, we return a new
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// function with fewer arguments
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// or go ahead and call the function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// with the final argument so we can
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// get back a value.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// NOTE: `applyCurry` is defined below.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-kr">const</span> <span class="pl-nx">val</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-nx">args</span><span class="pl-p">.</span><span class="pl-nx">length</span> <span class="pl-o">===</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">length</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-o">?</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">apply</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">,</span> <span class="pl-nx">args</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">        <span class="pl-o">:</span> <span class="pl-nx">args</span><span class="pl-p">.</span><span class="pl-nx">reduce</span><span class="pl-p">(</span><span class="pl-nx">applyCurry</span><span class="pl-p">,</span> <span class="pl-nx">fn</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-c1">// 3. if our value is still a function, then
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// let's return the curried version of our
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// function that still needs some arguments
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// to be applied and repeat everything above.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// otherwise, we're all done here, so
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-c1">// let's return the value.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>    <span class="pl-k">return</span> <span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">val</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-o">?</span> <span class="pl-nx">curry</span><span class="pl-p">(</span><span class="pl-nx">val</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">      <span class="pl-o">:</span> <span class="pl-nx">val</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">applyCurry</span> <span class="pl-o">=</span> <span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">,</span> <span class="pl-nx">arg</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-p">{</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// return whatever we received if
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// fn is actually NOT a function.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-k">if</span> <span class="pl-p">(</span><span class="pl-o">!</span><span class="pl-nx">isFunction</span><span class="pl-p">(</span><span class="pl-nx">fn</span><span class="pl-p">))</span> <span class="pl-p">{</span> <span class="pl-k">return</span> <span class="pl-nx">fn</span> <span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-c1">// if we have more than 1 argument
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// remaining to be applied, then let's
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// bind a value to the next argument and
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// keep going.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">//
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// otherwise, then yay let's go ahead
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// and call that function with the argument;
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// our `[ undefined ]` default saves us from
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-c1">// some potential headache here.
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span>  <span class="pl-k">return</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">length</span> <span class="pl-o">&gt;</span> <span class="pl-mi">1</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-o">?</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">bind</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">,</span> <span class="pl-nx">arg</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-o">:</span> <span class="pl-nx">fn</span><span class="pl-p">.</span><span class="pl-nx">call</span><span class="pl-p">(</span><span class="pl-kc">null</span><span class="pl-p">,</span> <span class="pl-nx">arg</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-p">}</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">isFunction</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-k">typeof</span> <span class="pl-nx">x</span> <span class="pl-o">===</span> <span class="pl-s1">'function'</span></span></span></code></pre><p>With all of these checks in here, we can now run the following code and have it all work:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-kr">const</span> <span class="pl-nx">add</span> <span class="pl-o">=</span> <span class="pl-nx">curry</span><span class="pl-p">((</span><span class="pl-nx">a</span><span class="pl-p">,</span> <span class="pl-nx">b</span><span class="pl-p">)</span> <span class="pl-p">=&gt;</span> <span class="pl-nx">a</span> <span class="pl-o">+</span> <span class="pl-nx">b</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">add</span> <span class="pl-c1">// =&gt; Function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; Function
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">)(</span><span class="pl-mi">2</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 3
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">,</span> <span class="pl-mi">2</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 3
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">,</span> <span class="pl-mi">2</span><span class="pl-p">,</span> <span class="pl-mi">99</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 3 (we don't care about the last one!)
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">add</span><span class="pl-p">(</span><span class="pl-mi">1</span><span class="pl-p">,</span> <span class="pl-mi">2</span><span class="pl-p">,</span> <span class="pl-mi">99</span><span class="pl-p">,</span> <span class="pl-mi">2000</span><span class="pl-p">)</span> <span class="pl-c1">// =&gt; 3 (we don't care about the last two!)
</span></span></span></code></pre><h2 id="curry-in-action"><code>curry</code> In Action</h2><p>If all of your functions are curried, you can start writing code that you never would have been able to before. Here is a small taste that we will cover more fully in a future Ramda Chops:</p><pre class="pl-chroma"><code><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// addOrRemove :: a -&gt; Array -&gt; Array
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">addOrRemove</span> <span class="pl-o">=</span> <span class="pl-nx">x</span> <span class="pl-p">=&gt;</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">ifElse</span><span class="pl-p">(</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">contains</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">),</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">without</span><span class="pl-p">(</span><span class="pl-k">of</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)),</span>
</span></span><span class="pl-line"><span class="pl-cl">    <span class="pl-nx">append</span><span class="pl-p">(</span><span class="pl-nx">x</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1">// addOrRemoveTest :: Array -&gt; Array
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-kr">const</span> <span class="pl-nx">addOrRemoveTest</span> <span class="pl-o">=</span>
</span></span><span class="pl-line"><span class="pl-cl">  <span class="pl-nx">addOrRemove</span><span class="pl-p">(</span><span class="pl-s1">'test'</span><span class="pl-p">)</span>
</span></span><span class="pl-line"><span class="pl-cl">
</span></span><span class="pl-line"><span class="pl-cl"><span class="pl-nx">addOrRemoveTest</span><span class="pl-p">([</span> <span class="pl-s1">'thing'</span> <span class="pl-p">])</span> <span class="pl-c1">// =&gt; ["thing", "test"]
</span></span></span><span class="pl-line"><span class="pl-cl"><span class="pl-c1"></span><span class="pl-nx">addOrRemoveTest</span><span class="pl-p">([</span> <span class="pl-s1">'thing'</span><span class="pl-p">,</span> <span class="pl-s1">'test'</span> <span class="pl-p">])</span> <span class="pl-c1">// =&gt; ["thing"]
</span></span></span></code></pre><p>(<a href="https://goo.gl/5uRhS2">View this example in a live REPL</a>)</p><p>The <code>addOrRemove</code> function almost reads like English: ‚ÄúIf something contains <code>x</code>, give me back that something without <code>x</code>; otherwise, append <code>x</code> to that something.‚Äù What is worth understanding here is that these functions each accept a number of arguments where <em>the most generic/reusable are provided first</em> (this is a tenet of Functional Programming). Here, we are able to create a very reusable function with partially applied values that sits and waits until the final bit ‚Äì an array ‚Äì is provided.</p><hr /><p>Thanks for reading! Until next time, <br> Robert</p></section></main><footer><span aria-hidden="true" class="heart">‚ô•</span><span aria-hidden="true">&rarr;</span><a href="https://github.com/sponsors/rpearce/">Sponsor my work</a><span aria-hidden="true">&larr;</span><span aria-hidden="true" class="heart">‚ô•</span></footer><script async> (() => { const themeEl = document.querySelector('[data-select-theme]'); if (themeEl) { themeEl.querySelector('[value="'+window.site.prefTheme+'"]').selected = 'selected'; themeEl.addEventListener('change', e => { window.site.setTheme(e.target.value); }); } const fontEl = document.querySelector('[data-select-font]'); if (fontEl) { fontEl.querySelector('[value="'+window.site.prefFont+'"]').selected = 'selected'; fontEl.addEventListener('change', e => { window.site.setFont(e.target.value); }) } })(); </script></body></html>